#+TITLE: Vincent Demeester's emacs configuration
#+AUTHOR: Vincent Demeester
#+EMAIL: vincent [at] demeester [dot] fr

#+BEGIN_SRC
                                                              ___ __
    .-----.--------.---.-.----.-----.______.----.-----.-----.'  _|__|.-----.
    |  -__|        |  _  |  __|__ --|______|  __|  _  |     |   _|  ||  _  |
    |_____|__|__|__|___._|____|_____|      |____|_____|__|__|__| |__||___  |
                                                                     |_____|
#+END_SRC

This is my first attempt to create a readable, maintainable and self
documented emacs configuration. I'm hopeful that using Org-Babel and a
literate programming style will help.

There is a lot of inspiration for this file, I'm just gonna list the
one I took the most of it :

- [[https://github.com/joodie/emacs-literal-config/blob/master/emacs.org][Joodie emacs-literal-config]]
- [[https://github.com/dakrone/dakrone-dotfiles/blob/master/.emacs.d/settings.org][Dakrone emacs configuration]]
- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]]
- [[https://github.com/steckerhalter/steckemacs/blob/master/steckemacs.org]["Steckemacs" steckerhalter literal emacs config]]
- [[https://github.com/larstvei/dot-emacs][Lartsvei dot-emacs]]
- [[https://github.com/grettke/home/blob/master/.emacs.el][Grettke emacs configuration]]
- [[https://github.com/jkitchin/jmax][Johns customizations to maximize emacs (jmax)]]
- [[https://github.com/jwiegley/dot-emacs][jwiegley dot-emacs]]

This file is an /always/ work-in-progress, and is currently under
*heavy* modifications. The latest version of this file is always
available at my [[https://github.com/vdemeester/emacs-config][emacs-config]] github repository, the [[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/emacs.org][emacs.org]] file.

It looks kinda like that (click to open the real one) :

[[./.emacs.d/images/emacs-config.png][./.emacs.d/images/emacs-config-small.png]]

* How to use my configuration ðŸš€

  You can obtain the source by cloning this repository somewhere, but the repository
  is made to work with [[https://github.com/RichiH/vcsh][vcsh]].

  #+BEGIN_SRC sh :tangle no
 vcsh clone git://github.com/vdemeester/emacs-config emacs-config
  #+END_SRC

  If you don't want to use =vcsh= but still want to have my =.emacs.d= folder
  in your =$HOME=, you could link it like that :

  #+BEGIN_SRC sh :tangle no
 $ cd $HOME
 $ mkdir -p src
 $ git clone git://github.com/vdemeester/emacs-config src/vde-emacs-config
 $ ln -s src/vde-emacs-config/.emacs.d .
  #+END_SRC

** The =init.el=

   If you just want to get the =emacs.org= file, you will have to define and setup
   some stuff for this file to work with org-babel. You could take a look to my
   [[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/init.el][init.el]] file but let's show the main stuff.

   First you will need to setup packages repository and define a =require-package=
   function, let's see what's in there (defined in =lisp/setup-package.el=).


   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'package)

     ;; add org to package repos
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

     ;; add melpa and melpa-stable to package repos
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
     (add-to-list 'package-archives '("mela-stable" . "http://stable.melpa.org/packages/"))

     ;; If gpg cannot be found, signature checking will fail, so we
     ;; conditionally enable it according whether gpg is available.
     ;; We re-run this check once $PATH has been configured
     (defun sanityinc/package-maybe-enable-signatures ()
       (setq package-check-signature (when (executable-find "gpg") 'allow-unsigned)))

     (sanityinc/package-maybe-enable-signatures)

     ;; Fire up package.el
     (package-initialize)

     ;; Load package contents if not present
     (when (not package-archive-contents)
       (package-refresh-contents))

     ;; Load use-package
     (require 'use-package)

     (provide 'setup-package)
   #+END_SRC

   Let's now see how I load the =emacs.org= file. In the following lines of code,
   I'm also ensuring that a recent version of [[http://orgmode.org/][org-mode]] is present on the system ;
   if not, I'm unload the current one, installing a recent one and load it.

   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Support for Emacs 24 and higher only
     (let ((minver 24))
       (unless (>= emacs-major-version minver)
         (error "Your Emacs is too old -- this config requires v%s or higher" minver)))

     ;; Keep track of loading time
     (defconst emacs-start-time (current-time))

     ;; Add custom lisp files to the load-path
     (add-to-list 'load-path "~/.emacs.d/lisp")
     ;; Add a specific version of use-package
     (add-to-list 'load-path "~/.emacs.d/lisp/use-package")

     (require 'vde-functions)
     ;; initialize all ELPA packages
     (require 'setup-package)

     (let ((elapsed (float-time (time-subtract (current-time)
                                                emacs-start-time))))
       (message "Loaded packages in %.3fs" elapsed))

     ;; Make sure we have a decent and recent org-mode version
     (require 'org)
     (when (string-match "^[1234567]" (org-version))
       (progn
         (warn "Org-mode is out of date. We expect org 8 or higher, but instead we have %s" (org-version))
         (warn "Force the installation from org elpa.")
         (package-install 'org)
         (unload-org-mode)
         (require 'org)
         ))

     ;; keep customize settings in their own file
     (setq custom-file
           (expand-file-name "custom.el"
                             user-emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))

     ;; load the literate configuration
     (require 'ob-tangle)

     (org-babel-load-file "~/.emacs.d/emacs.org")

     (let ((elapsed (float-time (time-subtract (current-time)
                                                emacs-start-time))))
       (message "Loaded settings...done in %.3fs" elapsed))
   #+END_SRC

** Tangle on save

   This was taken and adapted from [[https://github.com/alanpearce/dotfiles/blob/master/tag-emacs/emacs.d/init.org#tangling][Alan Pearce's dotfiles]] so as to tangle
   it on save instead of tangling it every time I open it again.

   /Note/: async doesn't work here.. thinking of moving this definition
   away (in a separate =lisp= file) and load it/run it async. For now
   it's freezing a bit when saving this file...

   #+BEGIN_SRC emacs-lisp
  (defun tangle-if-config ()
    "If the current buffer is a config '*.org' the code-blocks are
      tangled, and the tangled file is compiled."
    (when (member (file-name-nondirectory buffer-file-name) '("emacs.org" "provided/go-config.org"))
      (tangle-config buffer-file-name)))

  (defun tangle-config-sync (file-name)
    (interactive)

    ;; Avoid running hooks when tangling.
    (let* ((prog-mode-hook nil)
           (src  file-name)
           ;; (dest (expand-file-name "emacs.el"  user-emacs-directory))
           (dest (format "%s.el" (file-name-sans-extension file-name))))
      (message (format "%s -> %s" src dest))
      (require 'ob-tangle)
      (org-babel-tangle-file src dest)
      (if (byte-compile-file dest)
          (byte-compile-dest-file dest)
        (with-current-buffer byte-compile-log-buffer
          (buffer-string)))))

  (defun tangle-config (file-name)
    "Tangle init.org asynchronously."

    (interactive)
    (message (format "Tangling %s" file-name))
    (tangle-config-sync file-name)
    ;; (async-start
    ;;  (lambda ()
    ;;    (set 'file-name ,file-name)
    ;;    (fset 'tangle-config-sync ,(symbol-function 'tangle-config-sync))
    ;;    (tangle-config-sync file-name))
    ;;  ;; (symbol-function #'tangle-config-sync)
    ;;  (lambda (result)
    ;;    (message "Init tangling completed: %s" result)))
    )
   #+END_SRC

** Edit configuration shortcut

   I like to have a quick shortcut to open this configuration file, so
   let's do that.

   #+BEGIN_SRC emacs-lisp
     (defun my/edit-emacs-configuration ()
       (interactive)
       (find-file "~/.emacs.d/emacs.org"))

     (global-set-key "\C-ce" 'my/edit-emacs-configuration)
   #+END_SRC

* Personal information ðŸ‘¨

  Let's define default value that could be owerwritten by the host
  and user file ðŸ£. The variables =user-full-name= and
  =user-mail-address= are defined in =~/.emacs.d/user.el= (which is
  private).

  #+BEGIN_SRC emacs-lisp
    (setq
     ;; General
     ;; TODO use xdg to get these
     desktop-folder (substitute-env-in-file-name "$HOME/desktop")
     videos-folder (expand-file-name "videos" desktop-folder)
     downloads-folder (expand-file-name "downloads" desktop-folder)
     music-folder (expand-file-name "music" desktop-folder)
     pictures-folder (expand-file-name "pictures" desktop-folder)
     ;; Orgmode related
     my-org-file "emacs.org"
     org-root-directory (substitute-env-in-file-name "$HOME/desktop/org")
     org-todos-directory-name "todos"
     org-notes-directory-name "notes"
     org-sites-directory-name "sites"
     org-archive-directory-name "archive"
     org-archive-file-pattern "/%s_archive::"
     org-inbox-file "inbox.org"
     org-main-file "personal.org"
     org-journal-file "journal.org"
     org-stackoverflow-file "stack.org"
     org-zenika-file "zenika.org"
     org-web-article-file "ent.org"
     org-publish-folder (substitute-env-in-file-name "$HOME/var/public_html")
     sites-folder (substitute-env-in-file-name "$HOME/src/sites/")
     ;; Github related
     github-general-folder (substitute-env-in-file-name "$HOME/src/github")
     github-username "vdemeester")
  #+END_SRC

  Loads user settings if the file is available. I put all my personal modifications or sensitive information into this file.

  #+BEGIN_SRC emacs-lisp
 (when (file-readable-p "~/.emacs.d/user.el")
   (load "~/.emacs.d/user.el"))
  #+END_SRC

  Same will goes with host-specific files and os-specific files.

  #+BEGIN_SRC emacs-lisp
 (setq FULLHOSTNAME (format "%s" system-name))
 (setq HOSTNAME (substring (system-name) 0 (string-match "\\." (system-name))))

 (setq HOSTNAME-FILE
       (expand-file-name
        (format "hosts/%s.el" HOSTNAME)
        "~/.emacs.d"))

 (when (file-readable-p HOSTNAME-FILE)
   (load HOSTNAME-FILE))
  #+END_SRC

  And build the /final/ variables with the possibly overwritten ones.


  #+BEGIN_SRC emacs-lisp
    (setq
     ;; Orgmode related
     org-todos-directory (expand-file-name org-todos-directory-name org-root-directory)
     org-notes-directory (expand-file-name org-notes-directory-name org-root-directory)
     org-sites-directory (expand-file-name org-sites-directory-name org-root-directory)
     org-archive-directory (expand-file-name org-archive-directory-name org-root-directory)
     ;; Github related
     github-personal-folder (expand-file-name github-username github-general-folder))
  #+END_SRC


* Defaults ðŸ£
** Disabling some GUI elements

   Unclutter the screen by removing menubar, toolbar and stuff.

   #+BEGIN_SRC emacs-lisp
     (when window-system
          (menu-bar-mode -1)
          (tool-bar-mode -1)
          (scroll-bar-mode -1)
          (blink-cursor-mode -1))
   #+END_SRC

   Let's also disable the startup-screen too.

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-splash-screen t)
   #+END_SRC

** Lines and columns

   We want to see somewhere the column and line number, and also highlight the
   current line to see it easily.

   #+BEGIN_SRC emacs-lisp
     (line-number-mode 1)
     (column-number-mode 1)
     (global-hl-line-mode 1)
   #+END_SRC

** Syntax highlighting

   Depending on the files opened and the syntax highlighting enabled, ~font-lock-mode~
   can be slow, we try to limit that, to keep Emacs reactive.

   #+BEGIN_SRC emacs-lisp
     (setq font-lock-maximum-decoration 2)
   #+END_SRC

** Fringe decorations

   [[http://www.emacswiki.org/emacs/TheFringe][The fringe]] is the vertical region at the right and left of the
   buffer. Emacs lets you customize it of course.

   Here I set up git diffs and buffer position in the fringe.

   #+BEGIN_SRC emacs-lisp
      (setq-default indicate-buffer-boundaries 'left)
      (setq-default indicate-empty-lines +1)
   #+END_SRC
** Backup files

   Files suffixed with =~= in the current directory are ugly. We are still going to use
   backup files, as it can saves some time in case of trouble, but we'll move them
   somewhere else : ~/tmp/emacs-1001~ (for a user with the uid = 1001).

   Note the we store them in /tmp so in case of a reboot, we loose them.

   #+BEGIN_SRC emacs-lisp
      (defconst emacs-tmp-dir (format "%s/%s%s/" temporary-file-directory "emacs" (user-uid)))
      (setq backup-directory-alist
            `((".*" . ,emacs-tmp-dir))
            auto-save-file-name-transforms
            `((".*" ,emacs-tmp-dir t))
            auto-save-list-file-prefix emacs-tmp-dir)
   #+END_SRC

   Now that all the temporary files are out of the way, we can keep more of them.

   #+BEGIN_SRC emacs-lisp
      (setq delete-old-versions t
            kept-new-versions 6
            kept-old-versions 2
            version-control t)
   #+END_SRC

** Encoding system

   Make sure that we use ~utf-8~ by default.

   #+BEGIN_SRC emacs-lisp
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-language-environment "UTF-8")
     (prefer-coding-system 'utf-8)
     (setq-default buffer-file-coding-system 'utf-8-auto-unix)
   #+END_SRC

** Lazier prompting

   Answering yes and no to each question from Emacs can be tedious, a
   single y or n will suffice.

   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   Let Emacs display the unfinished keystroke quickly (by default it's
   1 second).

   #+BEGIN_SRC emacs-lisp
     (setq echo-keystrokes 0.1)
   #+END_SRC

** Expand some words and auto-correct

   =abbrev-mode= or abbreviation mode is a built-in mode that
   auto-corrects the word you mistype on pressing space.

   #+BEGIN_SRC emacs-lisp
     (setq save-abbrevs 'silently)
     (setq-default abbrev-mode t)
   #+END_SRC

** Window management

   [[https://www.emacswiki.org/emacs/WinnerMode][Winner mode]] is an Emacs built-in package that lets you undo and
   redo window configurations. Incredibly useful since I keep
   splitting and merging windows all the time. Let's enable it.

   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'winner-mode)
       (winner-mode 1))
   #+END_SRC

** =ediff=

   The =diff-mode= of Emacs is pretty cool, but let's show important
   whitespace when in this mode.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'diff-mode-hook (lambda ()
                                 (setq-local whitespace-style
                                             '(face
                                               tabs
                                               tab-mark
                                               spaces
                                               space-mark
                                               trailing
                                               indentation::space
                                               indentation::tab
                                               newline
                                               newline-mark))
                                 (whitespace-mode 1)))
   #+END_SRC

   Setup ediff so that it does not open a new frame (it is a pain in a
   tiling window manager).

   #+BEGIN_SRC emacs-lisp
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
     (setq ediff-split-window-function 'split-window-horizontally)
     (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
   #+END_SRC

** =tramp=

   [[https://www.emacswiki.org/emacs/TrampMode][Tramp]] lets you edit files remotely from your local Emacs which is
   useful because it lets you have all the default configuration. Let's
   make sure the default protocol is =ssh=.

   #+BEGIN_SRC emacs-lisp
     (setq tramp-default-method "ssh"
           tramp-backup-directory-alist backup-directory-alist
           tramp-ssh-controlmaster-options "ssh")
   #+END_SRC
** Diminish minor modes from the mode line

   Now that we have made sure we have installed use-package, we will make
   sure another nice package to change the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Variables.html][mode-line minor mode list]]. For
   this, we can use use-package itself and also go ahead and diminish
   some built-in minor modes.

   #+BEGIN_SRC emacs-lisp
     (use-package diminish
       :ensure t
       :demand t
       :diminish (visual-line-mode . "Ï‰")
       :diminish hs-minor-mode
       :diminish abbrev-mode
       :diminish auto-fill-function
       :diminish subword-mode)
   #+END_SRC


   However, some built-in minor modes are notorious and don't seem to
   work with the above method. Let's diminish them using functions one
   by one.

*** Diminish =org-indent= mode

    I like to enable the [[http://orgmode.org/manual/Clean-view.html][org-indent mode]] for a clean view in Org mode
    and this doesn't seem to get diminish the usual way. We define a
    function and a add a hook to achieve this.

    #+BEGIN_SRC emacs-lisp
      (defun sk/diminish-org-indent ()
        (interactive)
        (diminish 'org-indent-mode ""))
      (add-hook 'org-indent-mode-hook 'sk/diminish-org-indent)
    #+END_SRC

*** Diminish =auto-revert= mode

    [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html][auto-revert mode]] is useful when Emacs auto-saves your file and you
    want to load the backup.

    #+BEGIN_SRC emacs-lisp
      (defun sk/diminish-auto-revert ()
        (interactive)
        (diminish 'auto-revert-mode ""))
      (add-hook 'auto-revert-mode-hook 'sk/diminish-auto-revert)
    #+END_SRC

*** Diminish =eldoc= mode

    Eldoc mode is a mode to display documentation for languages in
    Emacs.

    #+BEGIN_SRC emacs-lisp
      (defun sk/diminish-eldoc ()
        (interactive)
        (diminish 'eldoc-mode ""))
      (add-hook 'eldoc-mode-hook 'sk/diminish-eldoc)
    #+END_SRC

*** Diminish =subword= mode

    =subword-mode= is described [[*Move%20correctly%20over%20camelCased%20words][here]].

    #+BEGIN_SRC emacs-lisp
      (defun sk/diminish-subword ()
        (interactive)
        (diminish 'subword-mode ""))
      (add-hook 'subword-mode-hook 'sk/diminish-subword)
    #+END_SRC
** Move correctly over camelCase words

   One thing I really like in IntelliJ IDEA is the possibility to
   select part of camelcase word. Emacs has the same feature but
   cooler (easier to switch back and forth), and it's called
   =subword= mode.

   Let's enable it by default, and have a toggle-map entry (later
   defined) to /toggle/ it.

   #+BEGIN_SRC emacs-lisp
     (subword-mode)
   #+END_SRC

** Narrow to region

   This is such a an amazing feature but is disabled by default. Let's re-enable it. For further reference on narrow region, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][refer to the Emacs manual]].

   #+BEGIN_SRC emacs-lisp
     (put 'narrow-to-region 'disabled nil)
   #+END_SRC

** Recent files

   An Emacs "mode" is a collection of behavior. It has both major and
   minor modes. One such useful mode is the =recentf-mode=, which
   stands for recent files mode. Let's give configure some options and
   enable it.

   #+BEGIN_SRC emacs-lisp
     (setq recentf-max-saved-items 1000
           recentf-exclude '("/tmp/" "/ssh:")
           ;; disable recentf-cleanup on Emacs start, because it can cause
           ;; problems with remote files
           recentf-auto-cleanup 'never)
     (recentf-mode)
   #+END_SRC

*** Fonts

    I tend to install Ubuntu font family on all my computers, I like
    it :). But I don't want emacs to fail loading because they aren't
    there yet, so let's define =Ubuntu Mono= as fonts, only if they
    are available.

    #+BEGIN_SRC emacs-lisp
      (set-default-font "Ubuntu Mono-12")
      (set-frame-font "Ubuntu Mono-12")
      (set-face-attribute 'default nil :family "Ubuntu Mono" :height 110)
    #+END_SRC

    This will set Symbola as fallback-font for Emojis when it is
    available for the created frame. Because emojis and unicode are
    cool : ðŸ™† ðŸ˜† ðŸ˜ â™¨ â›… ðŸš².

    #+BEGIN_SRC emacs-lisp
      (set-fontset-font t 'unicode "Symbola" nil 'prepend)
    #+END_SRC


** Buffers

   Setup uniquify so that non-unique buffer names get the parent path included to make them unique.

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify)
     (setq uniquify-buffer-name-style 'forward)
   #+END_SRC

   Most of the time, when I want to kill the current buffer so let's
   remap the =C-x k= the a function that do that (and no ask) ; it
   will save few keystroke per days =\o/=.


   #+BEGIN_SRC emacs-lisp
     (defun kill-default-buffer ()
       "Kill the currently active buffer"
       (interactive)
       (let (kill-buffer-query-functions) (kill-buffer)))

     (global-set-key (kbd "C-x k") 'kill-default-buffer)
   #+END_SRC

   Also, let's use =ibuffer= for listing the buffer (which is bind to
   =C-x C-b=).

   #+BEGIN_SRC emacs-lisp
     (defalias 'list-buffers 'ibuffer) ; make ibuffer default
   #+END_SRC

** Zoom(ing)

   Being able to zoom in and out can be cool, especially when
   presenting something with emacs ; so that everybody can see
   what's written.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-+") 'text-scale-increase)
     (global-set-key (kbd "C--") 'text-scale-decrease)
   #+END_SRC

** Flyspell

   #+BEGIN_QUOTE
   Flyspell enables on-the-fly spell checking in Emacs by the means of
   a minor mode. It is called Flyspell. This facility is hardly
   intrusive. It requires no help. Flyspell highlights incorrect words
   as soon as they are completed or as soon as the TextCursor hits a
   new word.
   #+END_QUOTE


   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :ensure t
       :init
       (progn
         (use-package flyspell-lazy
           :ensure t))
       :config
       (progn
         (setq ispell-program-name "aspell")
         (setq ispell-local-dictionary "en_US")
         (setq ispell-local-dictionary-alist
               '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8)
                 ("fr_FR" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8)))
         (add-hook 'text-mode-hook 'flyspell-mode)
         (add-hook 'prog-mode-hook 'flyspell-prog-mode)))
   #+END_SRC
** Server mode

   Start a server in not already running. I usually start emacs as a
   daemon when at the start of the computer, but you never know =;-)=.

   I have an error about /unsafe directory/ for =/tmp/emacs100=, that's
   why the advice is there, to ignore the error (from [[http://stackoverflow.com/a/17069276/89249][stackoverflow]]).

   #+BEGIN_SRC emacs-lisp
     (defadvice server-ensure-safe-dir (around
                                        my-around-server-ensure-safe-dir
                                        activate)
       "Ignores any errors raised from server-ensure-safe-dir"
       (ignore-errors ad-do-it))
     (unless (string= (user-login-name) "root")
       (require 'server)
       (when (or (not server-process)
                 (not (eq (process-status server-process)
                          'listen)))
         (unless (server-running-p server-name)
           (server-start))))
   #+END_SRC
** Bind key to bind some unbound defaults

   There are some pretty nice default functions that are unbound. I use
   the =bind-key= package that comes along with use-package to bind these
   keys.

   #+BEGIN_SRC emacs-lisp
     (bind-keys*
       ("C-r"       . dabbrev-expand)
       ("M-/"       . hippie-expand)
       ("M-m SPC R" . locate)
       ("M-m W"     . winner-undo)
       ("M-m g m"   . make-frame)
       ("M-m g M"   . delete-frame)
       ("M-m g n"   . select-frame-by-name)
       ("M-m g N"   . set-frame-name)
       ("M-m B"     . mode-line-other-buffer)
       ("M-m ="     . indent-region)
       ("M-m g ("   . Info-prev)
       ("M-m g )"   . Info-next)
       ("M-m ^"     . Info-up)
       ("M-m &"     . Info-goto-node)
       ("M-m g f"   . find-file-at-point)
       ("M-m g u"   . downcase-region)
       ("M-m g U"   . upcase-region)
       ("M-m g C"   . capitalize-region)
       ("M-m g F"   . follow-mode)
       ("M-m R"     . overwrite-mode)
       ("M-m g j"   . doc-view-next-page)
       ("M-m g k"   . doc-view-previous-page)
       ("M-m : t"   . emacs-init-time)
       ("M-m g q"   . fill-paragraph)
       ("M-m g @"   . compose-mail)
       ("M-m SPC ?" . describe-bindings))
   #+END_SRC

* Key hints
** Which-key

   Emacs has 100s of bindings and it is impossible to remember them
   all. Sometimes I can remember the start of a key chord but not the
   entire one. [[https://github.com/justbur/emacs-which-key][Which-key]] is a package that gives you key hints on delay
   or if prompted. I really like it and use it extensively to setup the
   modal state.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :ensure t
       :defer t
       :diminish which-key-mode
       :init
       (setq which-key-sort-order 'which-key-key-order-alpha)
       :bind* (("M-m ?" . which-key-show-top-level))
       :config
       (which-key-mode)
       (which-key-add-key-based-replacements
         "M-m ?" "top level bindings"))
   #+END_SRC

** Discover my major

   [[https://github.com/steckerhalter/discover-my-major][This package]] helps to discover the major mode bindings. I use it
   very occasionally and hence not binding it to any modal binding.

   #+BEGIN_SRC emacs-lisp
     (use-package discover-my-major
       :ensure t
       :bind (("C-h C-m" . discover-my-major)
              ("C-h M-m" . discover-my-mode)))
   #+END_SRC
* Navigation ðŸš¢

  This section contains all the package and custom for navigating
  within the buffer, within a project, Emacs, etc.

** Hydra

   [[https://github.com/abo-abo/hydra][Hydra]] is not strictly a modal package but it is one that lets you
   define sticky bindings and I would call it semi-modal. I love it and
   need it.

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :ensure t)
   #+END_SRC

** Ivy, counsel and swiper

   An alternative to Helm (that I used before) is [[https://github.com/abo-abo/swiper][ivy, counsel and
   swiper]].

   - Ivy, a generic completion mechanism for Emacs.
   - Counsel, a collection of Ivy-enhanced versions of common Emacs commands.
   - Swiper, an Ivy-enhanced alternative to isearch.

*** ivy

    #+BEGIN_QUOTE
    Ivy is a generic completion mechanism for Emacs. While it operates
    similarly to other completion schemes such as icomplete-mode, Ivy
    aims to be more efficient, smaller, simpler, and smoother to use
    yet highly customizable.
    #+END_QUOTE

    #+BEGIN_SRC emacs-lisp
      (use-package ivy
        :ensure t
        :diminish ivy-mode
        :bind (("C-c C-r" . ivy-resume))
        :config
        (use-package ivy-hydra
          :ensure t)
        (ido-mode -1)
        ;; Enable ivy
        (ivy-mode 1)
        ;; Show recently killed buffers when calling `ivy-switch-buffer'
        (setq ivy-use-virtual-buffers t)
        (defun modi/ivy-kill-buffer ()
          (interactive)
          (ivy-set-action 'kill-buffer)
          (ivy-done))
        (bind-keys
         :map ivy-switch-buffer-map
         ("C-k" . modi/ivy-kill-buffer))
        (bind-keys
         :map ivy-minibuffer-map
         ;; Exchange the default bindings for C-j and C-m
         ("C-m" . ivy-alt-done) ; RET, default C-j
         ("C-j" . ivy-done) ; default C-m
         ("C-S-m" . ivy-immediate-done)
         ("C-t" . ivy-toggle-fuzzy)
         ("C-o" . hydra-ivy/body))
        ;; version of ivy-yank-word to yank from start of word
        (defun bjm/ivy-yank-whole-word ()
          "Pull next word from buffer into search string."
          (interactive)
          (let (amend)
            (with-ivy-window
             ;;move to last word boundary
             (re-search-backward "\\b")
             (let ((pt (point))
                   (le (line-end-position)))
               (forward-word 1)
               (if (> (point) le)
                   (goto-char pt)
                 (setq amend (buffer-substring-no-properties pt (point))))))
            (when amend
              (insert (replace-regexp-in-string " +" " " amend)))))

        ;; bind it to M-j
        (define-key ivy-minibuffer-map (kbd "M-j") 'bjm/ivy-yank-whole-word)
        )
    #+END_SRC

*** counsel

    #+BEGIN_QUOTE
    ivy-mode ensures that any Emacs command using completing-read-function uses ivy for completion.

    Counsel takes this further, providing versions of common Emacs
    commands that are customised to make the best use of ivy. For example,
    counsel-find-file has some additional keybindings. Pressing DEL will
    move you to the parent directory.
    #+END_QUOTE

    #+BEGIN_SRC emacs-lisp
      (use-package counsel
        :ensure t
        :bind (("C-x C-f" . counsel-find-file)
               ("C-h f" . counsel-describe-function)
               ("C-h v" . counsel-describe-variable)
               ("C-h i" . counsel-info-lookup-symbol)
               ("C-c C-u" . counsel-unicode-char)
               ("C-c s g" . counsel-git-grep)
               ("C-c s s" . counsel-pt)
               ("M-y" . counsel-yank-pop)
               ("M-x" . counsel-M-x)))
    #+END_SRC

*** swiper

    #+BEGIN_QUOTE
    Swiper is an alternative to isearch that uses ivy to show an
    overview of all matches.
    #+END_QUOTE

    #+BEGIN_SRC emacs-lisp
      (use-package swiper
        :ensure t
        :bind
        (([remap isearch-forward]  . swiper)
         ([remap isearch-backward] . swiper)))
    #+END_SRC

** Undo tree

   The default Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Undo.html][undo]] command is weird. Better undo and redo
   states are given by [[https://www.emacswiki.org/emacs/UndoTree][undo-tree]] mode and, as an added bonus, also
   gives a visualization tree. This is the only thing I used and
   really like with evil is =undo-tree= so let's keep and use it.

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :bind (("C-*" . undo-tree-undo))
       :init
       (progn
         (defalias 'redo 'undo-tree-redo)
         (defalias 'undo 'undo-tree-undo)
         (global-undo-tree-mode)
         )
       :config
       (progn
         (setq undo-tree-auto-save-history t)
         (let ((undo-dir (expand-file-name "undo" user-emacs-directory)))
           (setq undo-tree-history-directory-alist (list (cons "." undo-dir))))))
   #+END_SRC
** Avy

   [[https://github.com/abo-abo/avy][Avy]] is a package that lets you jump anywhere on screen based on
   character, characters, lines or words.

   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :ensure t
       :init
       (setq avy-keys-alist
             `((avy-goto-char-timer . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))
               (avy-goto-line . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))))
       :bind* (("M-m f" . avy-goto-char-timer)
               ("M-g g" . avy-goto-line)))
   #+END_SRC

** Window management
*** Ace window

    [[https://github.com/abo-abo/ace-window][This package]] allows way better window movement that the default
    =other-window= binding.

    #+BEGIN_SRC emacs-lisp
      (defun joe-scroll-other-window()
        (interactive)
        (scroll-other-window 1))
      (defun joe-scroll-other-window-down ()
        (interactive)
        (scroll-other-window-down 1))
      ;; From https://github.com/abo-abo/ace-window/wiki but adapted to bepo
      (use-package ace-window
        :ensure t
        :bind ([remap other-window] . ace-window)
        :config
        (set-face-attribute 'aw-leading-char-face nil :foreground "deep sky blue" :weight 'bold :height 3.0)
        (set-face-attribute 'aw-mode-line-face nil :inherit 'mode-line-buffer-id :foreground "lawn green")
        (setq aw-keys   '(?a ?u ?i ?e ?t ?s ?r)
              aw-dispatch-always t
              aw-dispatch-alist
              '((?y aw-delete-window      "Ace - Delete Window")
                (?x aw-swap-window        "Ace - Swap Window")
                (?\' aw-flip-window       "Ace - Flip Window")
                (?\. aw-split-window-vert "Ace - Split Vert Window")
                (?c aw-split-window-horz  "Ace - Split Horz Window")
                (?n delete-other-windows  "Ace - Maximize Window")
                (?k balance-windows)
                (?v winner-undo)
                (?o winner-redo)))

        (when (package-installed-p 'hydra)
          (defhydra hydra-window-size (:color red)
            "Windows size"
            ("c" shrink-window-horizontally "shrink horizontal")
            ("t" shrink-window "shrink vertical")
            ("s" enlarge-window "enlarge vertical")
            ("r" enlarge-window-horizontally "enlarge horizontal")
            ("+" text-scale-increase "increase text size")
            ("-" text-scale-decrease "decrease text size"))
          (defhydra hydra-window-frame (:color red)
            "Frame"
            ("e" make-frame "new frame")
            ("y" delete-frame "delete frame"))
          (defhydra hydra-window-scroll (:color red)
            "Scroll other window"
            ("'" joe-scroll-other-window "scroll")
            ("j" joe-scroll-other-window-down "scroll down"))
          (add-to-list 'aw-dispatch-alist '(?w hydra-window-size/body) t)
          (add-to-list 'aw-dispatch-alist '(?l hydra-window-scroll/body) t)
          (add-to-list 'aw-dispatch-alist '(?g hydra-window-frame/body) t))
        (ace-window-display-mode t)
        (winner-mode 1))
    #+END_SRC

*** Toggle zoom window

    I generally have multiple windows open and might need to zoom into
    one every now and then. I also might split them and change them. I
    would like to think of [[https://github.com/syohex/emacs-zoom-window][this package]] as smart zoom where I zoom into
    a window, split further, and have =winner= handle the history and
    just zoom right back out and continue working on the previous
    configuration. It also indicates if you are zoomed in or not via
    the status line color.

    #+BEGIN_SRC emacs-lisp
      (use-package zoom-window
        :ensure t
        :bind* (("M-m Z" . zoom-window-zoom)))
    #+END_SRC

*** Popwin

    #+BEGIN_QUOTE
    popwin is a popup window manager for Emacs which makes you free
    from the hell of annoying buffers such like *Help*, *Completions*,
    *compilation*, and etc.
    #+END_QUOTE

    That says it all, it's kind of a must.

    #+BEGIN_SRC emacs-lisp
      (use-package popwin
        :ensure t
        :config
        (progn
          (add-to-list 'popwin:special-display-config `("*Swoop*" :height 0.5 :position bottom))
          (add-to-list 'popwin:special-display-config `("*Warnings*" :height 0.5 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Procces List*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*Messages*" :height 0.5 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Backtrace*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*Compile-Log*" :height 0.3 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Remember*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*All*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*Go Test*" :height 0.3))
          (add-to-list 'popwin:special-display-config `("*Async Shell Command*" :height 0.3))
          (add-to-list 'popwin:special-display-config `(flycheck-error-list-mode :height 0.5 :regexp t :position bottom))
          (popwin-mode 1)
          (global-set-key (kbd "C-z") popwin:keymap)))
    #+END_SRC


*** Fullframe

    [[https://github.com/tomterl/fullframe][Fullframe]] advises commands to execute fullscreen, restoring the window
    setup when exiting.

    #+BEGIN_SRC emacs-lisp
      (use-package fullframe
        :ensure t
        :config
        (fullframe magit-status magit-mode-quit-window)
        (fullframe ibuffer ibuffer-quit)
        (fullframe list-packages quit-window))
    #+END_SRC

** Bookmarks navigation

   #+BEGIN_SRC emacs-lisp
          (defhydra sk/hydra-bookmarks (:color blue
                                        :hint nil)
            "
           _s_: set  _b_: bookmark   _j_: jump   _d_: delete   _q_: quit
            "
            ("s" bookmark-set)
            ("b" bookmark-save)
            ("j" bookmark-jump)
            ("d" bookmark-delete)
            ("q" nil :color blue))
     (bind-keys*
       ("M-m `" . sk/hydra-bookmarks/body))
   #+END_SRC

** Project management

*** Projectile

    #+BEGIN_QUOTE
    Projectile is a project interaction library for Emacs. Its goal is
    to provide a nice set of features operating on a project level
    without introducing external dependencies(when feasible). For
    instance - finding project files has a portable implementation
    written in pure Emacs Lisp without the use of GNU find (but for
    performance sake an indexing mechanism backed by external commands
    exists as well).
    #+END_QUOTE

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure t
        :bind* (("M-m SPC d"   . projectile-find-file)
                ("M-m SPC D"   . projectile-switch-project)
                ("M-m SPC TAB" . projectile-find-other-file))
        :diminish projectile-mode
        :config
        (setq projectile-keymap-prefix (kbd "C-c p"))
        (use-package projectile-direnv
          :ensure t
          :config (add-hook 'projectile-mode-hook 'projectile-direnv-export-variables))
        (setq projectile-completion-system 'ivy)
        (setq projectile-enable-caching t)
        (setq projectile-indexing-method 'alien)
        (setq projectile-create-missing-test-files t)
        (setq projectile-switch-project-action #'projectile-commander)
        (def-projectile-commander-method ?s
          "Open a *shell* buffer for the project."
          (projectile-run-shell))
        (def-projectile-commander-method ?c
          "Run `compile` in the project."
          (projectile-compile-project nil))
        (def-projectile-commander-method ?d
          "Open project root in dired."
          (projectile-dired))
        (def-projectile-commander-method ?F
          "Git fetch on the project."
          (magit-status)
          (call-interactively #'magit-fetch-all-prune))
        (add-hook 'prog-mode-hook 'projectile-mode)
        )
    #+END_SRC

*** Perspective

    [[https://github.com/nex3/perspective-el][Perspective]] is a minor mode that provides the ability to manage
    different workspaces. It integrates well with projectile.

    #+BEGIN_SRC emacs-lisp
      (use-package perspective
        :ensure t
        :init
        (progn
          (setq persp-show-modestring nil)
          (add-hook 'persp-switch-hook 'hack-dir-local-variables-non-file-buffer)
          (persp-mode)))
      (use-package persp-projectile
        :ensure t
        :requires perspective
        :bind* (("M-m SPC p" . projectile-persp-switch-project)))
    #+END_SRC
** Tags based navigation

   [[https://www.gnu.org/software/global/][GNU global]] is a code tagging system and I use it to navigate the code base. It can use different backends, including [[http://ctags.sourceforge.net][ctags]].

   #+BEGIN_SRC emacs-lisp
     (use-package ggtags
       :ensure t
       :diminish ggtags-mode
       :bind* (("M-m T"   . ggtags-find-tag-regexp)
               ("M-m g t" . ggtags-create-tags)
               ("M-m g T" . ggtags-update-tags))
       :init
       (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
       :config
       (add-hook 'prog-mode-hook 'ggtags-mode))
   #+END_SRC

* Visual ðŸ˜Ž
** Color theme(s)

   First let's install the theme(s) and load the new theme.

   #+BEGIN_SRC emacs-lisp
      (use-package apropospriate-theme
        :ensure t
        :config
        (load-theme 'apropospriate-dark t)
        )
   #+END_SRC

** Mode Line

   [[https://github.com/TheBB/spaceline][Spaceline]] is similar to the [[http://spacemacs.org][Spacemacs]] mode-line. I like it. It's pretty cool.

   #+BEGIN_SRC emacs-lisp
      (use-package spaceline-config
        :ensure spaceline
        :config
        (setq powerline-default-separator 'wave
              spaceline-workspace-numbers-unicode t
              spaceline-window-numbers-unicode t)
        (spaceline-spacemacs-theme)
        (spaceline-info-mode))
   #+END_SRC

** highlight-symbol

   #+BEGIN_QUOTE
   Automatic and manual symbol highlighting for Emacs
   #+END_QUOTE

   Highlights the word/symbol at point and any other occurrences in
   view. Also allows to jump to the next or previous occurrence.

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :config
       (progn
         (setq highlight-symbol-on-navigation-p t)
         (add-hook 'prog-mode-hook 'highlight-symbol-mode))
       :bind (("C-<f3>" . highlight-symbol-at-point)
              ("<f3>" . highlight-symbol-next)
              ("S-<f3>" . highlight-symbol-prev)
              ("M-<f3>" . highlight-symbol-query-replace)))
   #+END_SRC

** Volatile highlights

   I particularly like this [[https://github.com/k-talo/volatile-highlights.el][package]]. It gives visual feedback on some
   of the common operations like undo, copying and pasting and also
   inherits the color scheme very well.

   #+BEGIN_SRC emacs-lisp
     (use-package volatile-highlights
       :ensure t
       :demand t
       :diminish volatile-highlights-mode
       :config
       (volatile-highlights-mode t))
   #+END_SRC

** Highlight indentation

   Languages like Python and rarely even huge functions in C/C++ are
   indented and it's hard to judge it's scope. That's when [[https://github.com/antonj/Highlight-Indentation-for-Emacs][this
   package]] becomes particularly useful. I never leave this on. I
   always turn it on and the off pretty soon.

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-indentation
       :ensure t
       :commands (highlight-indentation-mode))
   #+END_SRC

** Fill column indicator

   [[https://www.emacswiki.org/emacs/FillColumnIndicator][This]] package is similar to [[*Column enforce mode][Column enforce mode]] but adds a line as a
   margin instead of being subtle. I make sure my code has a soft
   limit of 80 characters per line and a hard limit of 100 characters
   per line. Therefore I enable this for 80 characters and column
   enforce mode for 100.

   #+BEGIN_SRC emacs-lisp
     (use-package fill-column-indicator
       :ensure t
       :commands (fci-mode)
       :init
       (setq fci-rule-width 3
             fci-rule-column 79))
   #+END_SRC

** Origami - folding based on indentation/syntax

   Emacs has a built-in =hide-show= mode but it isn't great. [[https://github.com/gregsexton/origami.el][Origami]]
   improves it a bit.

   #+BEGIN_SRC emacs-lisp
     (use-package origami
       :ensure t
       :commands (origami-toggle-node)
       :bind* (("M-m -" . orgiami-toggle-node)))
   #+END_SRC

** Raindow identifiers

   I read an intersting article about [[https://medium.com/p/3a6db2743a1e/][how to make syntax highlighting more useful]]
   and I really like the concept. And guess what, there's a mode for that.

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-identifiers
       :ensure t
       :init (add-hook 'prog-mode-hook
                       'rainbow-identifiers-mode))
   #+END_SRC
** Hydras
*** Activate minor modes

    There are many minor modes that I don't need to be active all the
    time. And this hydra activates them on my command. This replace my
    previous =toogle-map=.

    #+BEGIN_SRC emacs-lisp
      (defhydra vde/hydra-of-activate (:color red
                                              :hint nil)
        "
             _f_: fill      _n_: number       _v_: wrap        _i_: indent    _k_: which-key     _q_: quit
             _t_: time      _u_: truncate     _y_: yasnippet   _m_: margin    _s_: smartparens
             _l_: flyspell  _a_: auto-comp    _d_: fold        _g_: ggtags    _e_: error
            "
        ("f" auto-fill-mode)
        ("t" display-time-mode)
        ("l" flyspell-mode)
        ("n" linum-mode)
        ("u" toggle-truncate-lines)
        ("a" company-mode)
        ("v" visual-line-mode)
        ("y" yas-global-mode)
        ("d" global-origami-mode)
        ("i" highlight-indentation-mode)
        ("m" fci-mode)
        ("g" ggtags-mode)
        ("k" which-key-mode)
        ("s" smartparens-strict-mode)
        ("e" global-flycheck-mode)
        ("q" nil :color blue))
      (bind-keys*
       ("M-m g a" . vde/hydra-of-activate/body))
    #+END_SRC

* Editing ðŸ–¦

  For writing text, I prefer Emacs to do line wrapping for me. Also, superfluous
  white-space should be shown. There is two choices here :
  =auto-fill-mode= and =visual-line-mode= ; the difference is the one is
  actually inserting linke breaks, when the other is just a visual
  thing. Most of the time I want =auto-fill-mode= in my text files (or
  =org-mode= files), so let's add this as default and handle special
  cases.

  #+BEGIN_SRC emacs-lisp
    (add-hook 'text-mode-hook
              (lambda()
                (turn-on-auto-fill)
                (setq show-trailing-whitespace 't))
              )
  #+END_SRC

** Selection

   One feature of IntelliJ that really rocks is the =C-w= shortcuts
   that select "intelligently". =exand-region= is doing this for
   emacs, see [[http://emacsrocks.com/e09.html][Emacs Rocks Episode 09]]. Let's bind this to =C-== in
   Emacs.

   Some functions/regions have complimenting expansions - you can expand inside the
   brackets or around the brackets. The small case letters after pressing the
   prefix =i= will select the inner blocks most of the time while the upper case
   letters after pressing prefix =i= will select the complete blocks. To do this,
   we need to define a few functions.

   #+BEGIN_SRC emacs-lisp
     (defun sk/mark-inside-org-code ()
       "Select inside an Org code block without the org specific syntax"
       (interactive)
       (er/mark-org-code-block)
       (next-line 1)
       (exchange-point-and-mark)
       (previous-line 1)
       (end-of-line 1))

     (defun sk/mark-around-LaTeX-environment ()
       "Select around a LaTeX environment with both the begin and end keywords"
       (interactive)
       (er/mark-LaTeX-inside-environment)
       (previous-line 1)
       (exchange-point-and-mark)
       (next-line 1)
       (end-of-line 1))

     (defun sk/mark-around-word ()
       "Mark the word and the adjacent whitespace"
       (interactive)
       (er/mark-word)
       (exchange-point-and-mark)
       (forward-char 1))

     (defun sk/mark-around-text-paragraph ()
       "Mark the paragraph and the newline"
       (interactive)
       (er/mark-text-paragraph)
       (exchange-point-and-mark)
       (next-line 1))

     (defun sk/mark-inside-LaTeX-math ()
       "Mark inside the latex math"
       (interactive)
       (er/mark-LaTeX-math)
       (forward-char 1)
       (exchange-point-and-mark)
       (backward-char 1))

     (defun sk/mark-inside-python-block ()
       "Mark inside a python block"
       (interactive)
       (er/mark-python-block)
       (next-line 1))

     (defun sk/mark-around-symbol ()
       "Mark around a symbol including the nearby whitespace"
       (interactive)
       (er/mark-symbol)
       (exchange-point-and-mark)
       (forward-char 1))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :ensure t
       :bind* (("C-=" . er/expand-region)
               ("M-m a o" . er/mark-org-code-block)
               ("M-m a w" . sk/mark-around-word)
               ("M-m a p" . sk/mark-around-text-paragraph)
               ("M-m a f" . er/mark-defun)
               ("M-m a e" . sk/mark-around-LaTeX-environment)
               ("M-m a t" . er/mark-LaTeX-math)
               ("M-m a m" . er/mark-python-block)
               ("M-m a q" . er/mark-outside-quotes)
               ("M-m a b" . er/mark-outside-pairs)
               ("M-m a u" . er/mark-url)
               ("M-m a c" . er/mark-comment)
               ("M-m a v" . sk/mark-around-symbol)
               ("M-m i p" . er/mark-text-paragraph)
               ("M-m i f" . er/mark-defun)
               ("M-m i w" . er/mark-word)
               ("M-m i e" . er/mark-LaTeX-inside-environment)
               ("M-m i t" . sk/mark-inside-LaTeX-math)
               ("M-m i u" . er/mark-url)
               ("M-m i c" . er/mark-comment)
               ("M-m i b" . er/mark-inside-pairs)
               ("M-m i q" . er/mark-inside-quotes)
               ("M-m i o" . sk/mark-inside-org-code)
               ("M-m i m" . sk/mark-inside-python-block)
               ("M-m i v" . er/mark-symbol)))
   #+END_SRC

** Comment/Uncomment region

   Something I'm really use to, with IntelliJ or Eclipse, is being
   able to quickly comment a line or a region with simple
   keystroke. If nothing is selected, it comments the current line,
   if there is a selection, it comments the line selected (even if
   the selection doesn't start at the beginning of line. Let's bind
   it to =C-M-/= (=Ctrl+Alt+/=).

   [[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]] improves on the existing =comment-dwim= command
   for easy commenting. Pretty useful.

   #+BEGIN_SRC emacs-lisp
     (use-package comment-dwim-2
       :ensure t
       :bind* (("C-M-/" . comment-dwim-2)))
   #+END_SRC

   There is a cool function in emacs wich is =commend-dwim= (bounded
   to =M-;=). This adds a comment at the right place (at the end of
   the line, up the method, etc..

** Smartparens

   [[https://github.com/Fuco1/smartparens][This package]] aims to be the one-stop solution for semantic language in any
   language. It is a little hard to wrap your head around though. I mostly use it
   for its wrapping and unwrapping features more than semantic navigation.

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :ensure t
       :demand t
       :bind* (("M-m m j" . sp-down-sexp)
               ("M-m m k" . sp-backward-up-sexp)
               ("M-m m h" . sp-backward-down-sexp)
               ("M-m m l" . sp-up-sexp)
               ("M-m m f" . sp-forward-sexp)
               ("M-m m b" . sp-backward-sexp)
               ("M-m m a" . sp-beginning-of-sexp)
               ("M-m m e" . sp-end-of-sexp)
               ("M-m m n" . sp-next-sexp)
               ("M-m m p" . sp-previous-sexp)
               ("M-m m >" . sp-forward-barf-sexp)
               ("M-m m <" . sp-backward-barf-sexp)
               ("M-m m )" . sp-forward-slurp-sexp)
               ("M-m m (" . sp-backward-slurp-sexp)
               ("M-m m x" . sp-transpose-sexp)
               ("M-m m d" . sp-kill-sexp)
               ("M-m m y" . sp-copy-sexp)
               ("M-m m u" . sp-unwrap-sexp)
               ("M-m m U" . sp-backward-unwrap-sexp)
               ("M-m m C" . sp-convolute-sexp)
               ("M-m m r" . sp-raise-sexp)
               ("M-m m s" . sp-split-sexp)
               ("M-m m S" . sp-splice-sexp)
               ("M-m m F" . sp-splice-sexp-killing-forward)
               ("M-m m B" . sp-splice-sexp-killing-backward)
               ("M-m m A" . sp-splice-sexp-killing-around))
       :diminish smartparens-mode
       :diminish smartparens-strict-mode
       :config
       (require 'smartparens-config)
       (smartparens-global-mode)
       (smartparens-global-strict-mode)
       (show-smartparens-global-mode)
       (which-key-add-key-based-replacements
         "M-m m" "move prefix"))
   #+END_SRC

** Killing

   Let's define few advice with =kill-ring-save= and =kill-region=.

   #+BEGIN_SRC emacs-lisp
     (defadvice kill-region (before slick-cut activate compile)
       "When called interactively with no active region, kill a single line instead."
       (interactive
        (if mark-active (list (region-beginning) (region-end))
          (list (line-beginning-position)
                (line-beginning-position 2)))))
   #+END_SRC

   Let's use a well done package for the killing machine :D.

   #+BEGIN_SRC emacs-lisp
     (use-package easy-kill
       :ensure t
       :bind (([remap kill-ring-save] . easy-kill)
              ([remap mark-sexp] . easy-mark))
       :config
       (use-package easy-kill-extras
         :ensure t
         :bind (([remap mark-word] . easy-mark-word)
                ([remap zap-to-char] . easy-mark-to-char))
         :config (add-to-list 'easy-kill-alist '(?^ backward-line-edge ""))
         (add-to-list 'easy-kill-alist '(?$ forward-line-edge ""))
         (add-to-list 'easy-kill-alist '(?b buffer ""))
         (add-to-list 'easy-kill-alist '(?< buffer-before-point ""))
         (add-to-list 'easy-kill-alist '(?> buffer-after-point ""))
         (add-to-list 'easy-kill-alist '(?f string-to-char-forward ""))
         (add-to-list 'easy-kill-alist '(?F string-up-to-char-forward ""))
         (add-to-list 'easy-kill-alist '(?t string-to-char-backward ""))
         (add-to-list 'easy-kill-alist '(?T string-up-to-char-backward ""))))
   #+END_SRC

** Interactive edit

   [[https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer][Iedit-mode]] is the bomb. Quick, fast edits of every symbol selected. Although [[*Multiple
   cursors][Multiple cursors]]
   has some more features, this is the best choice for quick renaming of variables/words.

   #+BEGIN_SRC emacs-lisp
     (use-package iedit
       :ensure t
       :commands (iedit-mode)
       :bind* (("M-m *" . iedit-mode)))
   #+END_SRC

** Multiple cursors

   [[https://github.com/magnars/multiple-cursors.el][Multiple cursors]] is an amazing, but admittedly quirky, package that needs
   some setting up. Also, this conflicts with [[*Modalka mode][Modalka mode]] and when having
   multiple cursors, it's best to stay in Emacs state. Since I use this for
   quick edits, I'm fine with this. Also, [[*Region bindings mode][Region bindings mode]] acts as a glue
   between this and its corresponding modal binding

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind* (("M-m ." . mc/edit-lines)
               ("M-m >" . mc/mark-next-like-this)
               ("M-m ," . mc/skip-to-next-like-this)
               ("M-m <" . mc/mark-previous-like-this)))
   #+END_SRC

*** Region bindings mode

    [[https://github.com/fgallina/region-bindings-mode][This]] is also kind of a modal mode. This activates only when a region is active. I use it exclusively for multiple cursors.

    #+BEGIN_SRC emacs-lisp
(use-package region-bindings-mode
  :ensure t
  :demand t
  :bind (:map region-bindings-mode-map
              ("<" . mc/mark-previous-like-this)
              ("," . mc/skip-to-next-like-this)
              (">" . mc/mark-next-like-this)
              ("." . mc/edit-lines))
  :diminish (region-bindings-mode . "Ï")
  :config
  (progn
    (add-hook 'after-init-hook 'region-bindings-mode-enable)))
    #+END_SRC

** Moving text around

   Allows to move the current line or region up/down. The source code is
   on the Wiki: http://www.emacswiki.org/emacs/move-text.el

   #+BEGIN_SRC emacs-lisp
     (use-package move-text
       :ensure t
       :config (move-text-default-bindings))
   #+END_SRC
** Snippets

   [[https://github.com/capitaomorte/yasnippet][Yasnippets]] gives you the snippets functionality. It also comes bundled
   with a lot of pre-configured snippets and is extensible via Emacs
   Lisp. This following code also includes [[https://github.com/abo-abo/auto-yasnippet][auto-yasnippet]] to create
   temporary snippets and save them later if need be. It acts as a good
   compliment to the Yasnippets package. Also, this is the only package
   where many of the bindings have no equivalent in modal mode because it
   makes no sense. Just press the "trigger" (by visiting the snippet file
   using =C-<escape>=) and "TAB" to expand and jump. If you don't use
   snippets all that much, then seeing the list of all snippets by
   pressing "S" in modal mode should be good enough. Furthermore, I have
   set =C-o= to list all snippets in Emacs state but this maybe changed by
   mode specific keybindings.

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :diminish (yas-minor-mode . "Î³")
       :config
       (setq yas-verbosity 1
             yas/triggers-in-field t ; enable nested triggering of snippets
             yas-snippet-dir (expand-file-name "snippets" user-emacs-directory))
       (define-key yas-minor-mode-map (kbd "<tab>") nil)
       (define-key yas-minor-mode-map (kbd "TAB") nil)
       (define-key yas-minor-mode-map (kbd "<C-tab>") 'yas-expand)
       (add-hook 'snippet-mode-hook '(lambda () (setq-local require-final-newline nil)))
       (yas-global-mode))
   #+END_SRC

   Also, I don't want to trigger snippets when I'm in shell. So, let's turn it off.

   #+BEGIN_SRC emacs-lisp
     (defun sk/force-yasnippet-off ()
       (yas-minor-mode -1)
       (setq yas-dont-activate t))
     (add-hook 'term-mode-hook 'sk/force-yasnippet-off)
     (add-hook 'shell-mode-hook 'sk/force-yasnippet-off)
   #+END_SRC

** Writable grep

   wgrep allows you to edit a grep buffer and apply those changes to
   the file buffer. This is pretty /badass/ when doing some
   refactoring.

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep
       :ensure t)
   #+END_SRC

** Custom functions
*** Better move-beginning-of-line

    Let's also rewrite some built-in to better /default/. Let's start with
    [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][smarter navigation to the beginning of a line]].

    #+BEGIN_SRC emacs-lisp
      (defun smarter-move-beginning-of-line (arg)
        "Move point back to indentation of beginning of line.

      Move point to the first non-whitespace character on this line.
      If point is already there, move to the beginning of the line.
      Effectively toggle between the first non-whitespace character and
      the beginning of the line.

      If ARG is not nil or 1, move forward ARG - 1 lines first.  If
      point reaches the beginning or end of the buffer, stop there."
        (interactive "^p")
        (setq arg (or arg 1))

        ;; Move lines first
        (when (/= arg 1)
          (let ((line-move-visual nil))
            (forward-line (1- arg))))

        (let ((orig-point (point)))
          (back-to-indentation)
          (when (= orig-point (point))
            (move-beginning-of-line 1))))

      ;; remap C-a to `smarter-move-beginning-of-line'
      (global-set-key [remap move-beginning-of-line]
                      'smarter-move-beginning-of-line)
    #+END_SRC

*** Untabify the buffer

    #+BEGIN_SRC emacs-lisp
      (defun my/untabify-buffer ()
        "Untabify the currently visited buffer."
        (interactive)
        (untabify (point-min) (point-max)))

      (defun my/untabify-region-or-buffer ()
        "Untabify a region if selected, otherwise the whole buffer."
        (interactive)
        (unless (member major-mode indent-sensitive-modes)
          (save-excursion
            (if (region-active-p)
                (progn
                  (untabify (region-beginning) (region-end))
                  (message "Untabify selected region."))
              (progn
                (my/untabify-buffer)
                (message "Untabify buffer.")))
            )))
    #+END_SRC

*** Indent the buffer (using the current mode)

    #+BEGIN_SRC emacs-lisp
      (defun my/indent-buffer ()
        "Indent the currently visited buffer."
        (interactive)
        (indent-region (point-min) (point-max)))

      (defun my/indent-region-or-buffer ()
        "Indent a region if selected, otherwise the whole buffer."
        (interactive)
        (unless (member major-mode indent-sensitive-modes)
          (save-excursion
            (if (region-active-p)
                (progn
                  (indent-region (region-beginning) (region-end))
                  (message "Indented selected region."))
              (progn
                (my/indent-buffer)
                (message "Indented buffer.")))
            (whitespace-cleanup))))
    #+END_SRC

    Let's bind it.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-C i") 'my/indent-region-or-buffer)
    #+END_SRC

*** Cleanup buffer/region

    #+BEGIN_SRC emacs-lisp
        (defun my/cleanup-buffer ()
          "Perform a bunch of operations on the whitespace content of a buffer."
          (interactive)
          (my/indent-buffer)
          (my/untabify-buffer)
          (delete-trailing-whitespace))

      (defun my/cleanup-region (beg end)
        "Remove tmux artifacts from region."
        (interactive "r")
        (dolist (re '("\\\\â”‚\Â·*\n" "\W*â”‚\Â·*"))
          (replace-regexp re "" nil beg end)))
    #+END_SRC

    Let's bind these two.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-x M-t") 'my/cleanup-region)
      (global-set-key (kbd "C-c n") 'my/cleanup-buffer)
    #+END_SRC

* Org ê™®

  #+BEGIN_QUOTE
  Org-mode is a powerful system for organizing your complex life with
  simple plain-text files. It seamlessly integrates all your notes,
  mindmaps, TODO lists, calendar, day planner, and project schedules into
  a single system that can be easily searched (e.g. by grep), encrypted
  (e.g. by GnuPG), backed up and synced (e.g. by Dropbox),
  imported/exported, and accessed on the go (e.g. on an iPhone or Android
  smartphone). It can even be used for authoring web pages and documents.
  #+END_QUOTE

  Depending on how this section grows, org-mode might need its own litterate
  org configuration file.

** Standard configuration

   First let's define the default directory for the =org= files, the one to be added
   to the agenda and the archives.

   #+BEGIN_SRC emacs-lisp
     (require 'find-lisp)
     (setq org-directory org-root-directory)
     (setq org-agenda-files (find-lisp-find-files org-todos-directory "\.org$"))
     ;; (setq org-enforce-todo-dependencies t)
     (setq org-enforce-todo-checkbox-dependencies t)

     ;;open agenda in current window
     (setq org-agenda-window-setup (quote current-window))
     ;;warn me of any deadlines in next 7 days
     (setq org-deadline-warning-days 7)
     ;;show me tasks scheduled or due in next fortnight
     (setq org-agenda-span (quote fortnight))
     ;;don't show tasks as scheduled if they are already shown as a deadline
     (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
     ;;don't give awarning colour to tasks with impending deadlines
     ;;if they are scheduled to be done
     (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))
     ;;don't show tasks that are scheduled or have deadlines in the
     ;;normal todo list
     (setq org-agenda-todo-ignore-deadlines (quote all))
     (setq org-agenda-todo-ignore-scheduled (quote all))
     ;;sort tasks in order of when they are due and then by priority
     (setq org-agenda-sorting-strategy
       (quote
        ((agenda deadline-up priority-down)
         (todo priority-down category-keep)
         (tags priority-down category-keep)
         (search category-keep))))
   #+END_SRC

   The GUI Emacs has the ability to display images. But if the image is pretty large, it displays the whole thing. Let's restrict it from doing that.

   #+BEGIN_SRC emacs-lisp
     (setq org-image-actual-width '(300))
   #+END_SRC

   We'll also set which files should be opened using org-mode :
   =*.org=, =*.org_archive=, =*.txt=.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
   #+END_SRC

   Let's /beautify/ org-mode a little bit too, changing some
   defaults

   #+BEGIN_SRC emacs-lisp
     ;;; Change the ellipsis (default is ...)
     (setq org-ellipsis " â†´")
     ;; Change the default bullets
     (font-lock-add-keywords 'org-mode
                             '(("^ +\\([-*]\\) "
                                (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))
     ;;; Use org-bullets
     (use-package org-bullets
       :config
       (setq org-bullets-face-name (quote org-bullet-face))
       (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
   #+END_SRC


   Let's also define the default /todo-keywords/ and the workflow
   between them.

   - =TODO= : task not started yet, part of the backlog :)
   - =PROGRESS= : task that are currently in progress, should be a minimum
   - =BLOCKED= : task that I start working on but cannot anymore (for
     some reason), thus they are blocked
   - =REVIEW= : task that should be done, but I need or wait for a
     review (by someone else or by me)
   - =DONE= : task that are completed.
   - =ARCHIVED= : same as done but keep it here (and not moving into archive)

     #+BEGIN_SRC emacs-lisp
       (defface org-progress ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#A197BF" :bold t :background "#E8E6EF" :box (:line-width 1 :color "#A197BF")))
             (((class color) (min-colors 8)  (background light)) (:foreground "blue"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PROGRESS keywords."
         :group 'org-faces)
       (defface org-paused ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#D6CCF4" :bold t :background "#ECE9F5" :box (:line-width 1 :color "#D6CCF4")))
             (((class color) (min-colors 8)  (background light)) (:foreground "cyan"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PAUSED keywords."
         :group 'org-faces)
       (defface org-cancelled ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#3D3D3D" :bold t :background "#7A7A7A" :box (:line-width 1 :color "#3D3D3D")))
             (((class color) (min-colors 8)  (background light)) (:foreground "black"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PROGRESS keywords."
         :group 'org-faces)
       (defface org-review ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#FC9B17" :bold t :background "#FEF2C2" :box (:line-width 1 :color "#FC9B17")))
             (((class color) (min-colors 8)  (background light)) (:foreground "yellow"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PROGRESS keywords."
         :group 'org-faces)
       (defface org-blocked ; font-lock-warning-face
         (org-compatible-face nil
           '((((class color) (min-colors 16) (background light)) (:foreground "#FF8A80" :bold t :background "#ffdad6" :box (:line-width 1 :color "#FF8A80")))
             (((class color) (min-colors 8)  (background light)) (:foreground "red"  :bold t))
             (t (:inverse-video t :bold t))))
         "Face for PROGRESS keywords."
         :group 'org-faces)

       (setq org-todo-keywords
             (quote ((sequence "TODO(t!)" "PROGRESS(p!)" "PAUSED" "BLOCKED" "REVIEW" "|" "DONE(d!)" "ARCHIVED")
                     (sequence "REPORT(r!)" "BUG" "KNOWNCAUSE" "|" "FIXED(f!)")
                     (sequence "|" "CANCELLED(c@)"))))

       ;; FIXME(vdemeester) rework the faces, it's ugly on current theme...
       (setq org-todo-keyword-faces
             (quote (("TODO" . org-todo)
                     ("PROGRESS" . org-progress)
                     ("PAUSED" . org-paused)
                     ("BLOCKED" . org-blocked)
                     ("REVIEW" . org-review)
                     ("DONE" . org-done)
                     ("ARCHIVED" . org-done)
                     ("CANCELLED" . org-cancelled)
                     ("REPORT" . org-todo)
                     ("BUG" . org-blocked)
                     ("KNOWNCAUSE" . org-review)
                     ("FIXED" . org-done))))

       (setq org-todo-state-tags-triggers
             (quote (("CANCELLED" ("CANCELLED" . t)))))
     #+END_SRC


   I have a folder with notes, where I don't want =auto-fill-mode=
   enabled, but =visual-line-mode=, let's do that.

   #+BEGIN_SRC emacs-lisp
     (defun turn-on-auto-visual-line (expression)
       (if buffer-file-name
           (cond ((string-match expression buffer-file-name)
                  (progn
                    (auto-fill-mode -1)
                    (visual-line-mode 1))
                  ))))
   #+END_SRC

   Undefine some binding (=C-c [=, =C-c ]= since this breaks org-agenda files that
   have been defined in this file (a directory).

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook
               '(lambda ()
                  (org-defkey org-mode-map "\C-c[" 'undefined)
                  (org-defkey org-mode-map "\C-c]" 'undefined)
                  (org-defkey org-mode-map "\C-c;" 'undefined)
                  (turn-on-auto-visual-line (concat org-notes-directory "/*")))
               'append)
   #+END_SRC

   All org-mode buffers will be automatically saved each hours.

   #+BEGIN_SRC emacs-lisp
     (run-at-time "00:59" 3600 'org-save-all-org-buffers)
   #+END_SRC

   And add some miscellaneous stuff.

   #+BEGIN_SRC emacs-lisp
     (setq
      org-cycle-separator-lines 0      ;; Don't show blank lines
      org-catch-invisible-edits 'error ;; don't edit invisible text
      org-refile-targets '((org-agenda-files . (:maxlevel . 6)))
      )
   #+END_SRC

   If a parent has all it's children =DONE=, make it =DONE= too.

   #+BEGIN_SRC emacs-lisp
    (defun org-summary-todo (n-done n-not-done)
      "Switch entry to DONE when all subentries are done, to PROGRESS otherwise."
      (let (org-log-done org-log-states)   ; turn off logging
        (org-todo (if (= n-not-done 0) "DONE" "PROGRESS"))))

    (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
   #+END_SRC

   Also, setup some nice template expansion, usable with =<= before them.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-structure-template-alist '("A" "#+DATE: ?"))
     (add-to-list 'org-structure-template-alist '("C" "#+BEGIN_CENTER\n?\n#+END_CENTER\n"))
     (add-to-list 'org-structure-template-alist '("D" "#+DESCRIPTION: ?"))
     (add-to-list 'org-structure-template-alist '("E" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE\n"))
     (add-to-list 'org-structure-template-alist '("L" "#+BEGIN_LaTeX\n?\n#+END_LaTeX"))
     (add-to-list 'org-structure-template-alist '("N" "#+NAME: ?"))
     (add-to-list 'org-structure-template-alist '("S" "#+SUBTITLE: ?"))
     (add-to-list 'org-structure-template-alist '("T" ":DRILL_CARD_TYPE: twosided"))
     (add-to-list 'org-structure-template-alist '("V" "#+BEGIN_VERSE\n?\n#+END_VERSE"))
     (add-to-list 'org-structure-template-alist '("a" "#+AUTHOR: ?"))
     (add-to-list 'org-structure-template-alist '("c" "#+CAPTION: ?"))
     (add-to-list 'org-structure-template-alist '("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
     (add-to-list 'org-structure-template-alist '("g" "#+BEGIN_SRC golang\n?\n#+END_SRC"))
     (add-to-list 'org-structure-template-alist '("f" "#+TAGS: @?"))
     (add-to-list 'org-structure-template-alist '("h" "#+BEGIN_HTML\n?\n#+END_HTML\n"))
     (add-to-list 'org-structure-template-alist '("k" "#+KEYWORDS: ?"))
     (add-to-list 'org-structure-template-alist '("l" "#+LABEL: ?"))
     (add-to-list 'org-structure-template-alist '("n" "#+BEGIN_NOTES\n?\n#+END_NOTES"))
     (add-to-list 'org-structure-template-alist '("o" "#+OPTIONS: ?"))
     (add-to-list 'org-structure-template-alist '("p" "#+BEGIN_SRC python\n?\n#+END_SRC"))
     (add-to-list 'org-structure-template-alist '("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE"))
     (add-to-list 'org-structure-template-alist '("r" ":PROPERTIES:\n?\n:END:"))
     (add-to-list 'org-structure-template-alist '("s" "#+BEGIN_SRC ?\n#+END_SRC\n"))
     (add-to-list 'org-structure-template-alist '("t" "#+TITLE: ?"))
   #+END_SRC

** Speed commands

   Org-mode speed keys (or spee commands) are really cool, here is a
   quotation from the manual

   #+BEGIN_QUOTE
   Single keys can be made to execute commands when the cursor is at the beginning of a headline, i.e., before the first star.
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
     (setq org-use-speed-commands t)
   #+END_SRC

   However the default =n= (next) and =p= (previous) speed keys
   aren't optimal for my use. When I go to the next one using speed
   commands I want the others closed. Let's redefine it.

   #+BEGIN_SRC emacs-lisp
     (defun my/org-show-next-heading-tidily ()
       "Show next entry, keeping other entries closed."
       (if (save-excursion (end-of-line) (outline-invisible-p))
           (progn (org-show-entry) (show-children))
         (outline-next-heading)
         (unless (and (bolp) (org-on-heading-p))
           (org-up-heading-safe)
           (hide-subtree)
           (error "Boundary reached"))
         (org-overview)
         (org-reveal t)
         (org-show-entry)
         (show-children)))

     (defun my/org-show-previous-heading-tidily ()
       "Show previous entry, keeping other entries closed."
       (let ((pos (point)))
         (outline-previous-heading)
         (unless (and (< (point) pos) (bolp) (org-on-heading-p))
           (goto-char pos)
           (hide-subtree)
           (error "Boundary reached"))
         (org-overview)
         (org-reveal t)
         (org-show-entry)
         (show-children)))
   #+END_SRC

   And let's bind it.

   #+BEGIN_SRC emacs-lisp
     (setq org-speed-commands-user '(("n" . my/org-show-next-heading-tidily)
                                     ("p" . my/org-show-previous-heading-tidily)
                                     (":" . org-set-tags-command)
                                     ("c" . org-toggle-checkbox)
                                     ("d" . org-cut-special)
                                     ("P" . org-set-property)
                                     ("C" . org-clock-display)
                                     ("z" . (lambda () (interactive)
                                              (org-tree-to-indirect-buffer)
                                              (other-window 1)
                                              (delete-other-windows)))))
   #+END_SRC

** Captures

   Let's define some useful functionâ€¦ Mainly add support for allowing
   prompt input in templates (see [[http://storax.github.io/blog/2016/05/02/org-capture-tricks/][org-capture-tricks]]).

   #+BEGIN_SRC emacs-lisp
     (defvar oc-capture-prmt-history nil
       "History of prompt answers for org capture.")
     (defun oc/prmt (prompt variable)
       "PROMPT for string, save it to VARIABLE and insert it."
       (make-local-variable variable)
       (set variable (read-string (concat prompt ": ") nil oc-capture-prmt-history)))
     (defun oc/inc (what text &rest fmtvars)
       "Ask user to include WHAT.  If user agrees return TEXT."
       (when (y-or-n-p (concat "Include " what "?"))
         (apply 'format text fmtvars)))
   #+END_SRC

   Setup captures templates..

   #+BEGIN_SRC emacs-lisp
     (setq org-capture-templates
           '(;; other entries
             ("t" "Inbox list item" entry
              (file+headline (expand-file-name org-main-file org-todos-directory) "Inbox")
              "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n")
             ("d" "Docker task" entry
              (file+headline (expand-file-name org-main-file org-todos-directory) "Tasks")
              "* TODO gh:docker/%(oc/prmt \"project\" 'd-prj)#%(oc/prmt \"issue/pr\" 'd-issue) %?%(oc/inc \"feature content\" \" [/]\n- [ ] Implementation\n- [ ] Tests\n- [ ] Docs\")")
             ("j" "Journal entry" plain
              (file+datetree+prompt (expand-file-name org-journal-file org-root-directory))
              "%K - %a\n%i\n%?\n")
             ;; other entries
             ))
   #+END_SRC

** Links

   #+BEGIN_QUOTE
   One little-know feature of org-mode is that you can define new
   types of links with the aptly named org-add-link-type. The
   applications of this virtue are many.
   #+END_QUOTE

   Let's define one for =grep= and =pt=.

   #+BEGIN_SRC emacs-lisp
     (org-add-link-type
      "grep" 'my/follow-grep-link
      )
     (defun my/follow-grep-link (regexp)
       "Run `rgrep' with REGEXP and FOLDER as argument,
     like this : [[grep:REGEXP:FOLDER]]."
       (setq expressions (split-string regexp ":"))
       (setq exp (nth 0 expressions))
       (grep-compute-defaults)
       (if (= (length expressions) 1)
           (progn
             (rgrep exp "*" (expand-file-name "./")))
         (progn
           (setq folder (nth 1 expressions))
           (rgrep exp "*" (expand-file-name folder))))
       )

     (use-package pt
       :load-path "~/.emacs.d/lisp/pt/")

     ;; pt-regexp (regexp directory &optional args)
     (org-add-link-type
      "pt" 'my/follow-pt-link)
     (defun my/follow-pt-link (regexp)
       "Run `pt-regexp` with REXEP and FOLDER as argument,
     like this : [[pt:REGEXP:FOLDER]]"
       (setq expressions (split-string regexp ":"))
       (setq exp (nth 0 expressions))
       (if (= (length expressions) 1)
           (progn
             (pt-regexp exp (expand-file-name "./")))
         (progn
           (setq folder (nth 1 expressions))
           (pt-regexp exp (file-name-as-directory (expand-file-name folder)))))
       )
   #+END_SRC

   Let's define some for youtube and other media websites.

   #+BEGIN_SRC emacs-lisp
     (defvar yt-iframe-format
       ;; You may want to change your width and height.
       (concat "<iframe width=\"440\""
               " height=\"335\""
               " src=\"https://www.youtube.com/embed/%s\""
               " frameborder=\"0\""
               " allowfullscreen>%s</iframe>"))

     (org-add-link-type
      "youtube"
      (lambda (handle)
        (browse-url
         (concat "https://www.youtube.com/embed/"
                 handle)))
      (lambda (path desc backend)
        (cl-case backend
          (html (format yt-iframe-format
                        path (or desc "")))
          (latex (format "\href{%s}{%s}"
                         path (or desc "video"))))))
   #+END_SRC

   Let's define some for github.com sites.


   #+BEGIN_SRC emacs-lisp
     (org-add-link-type
      "gh" 'my/follow-gh-link)
     (defun my/follow-gh-link (issue)
       "Browse github issue/pr specified"
       (setq expressions (split-string issue "#"))
       (setq project (nth 0 expressions))
       (setq issue (nth 1 expressions))
       (browse-url
        (format "https://github.com/%s/issues/%s" project issue)))
   #+END_SRC


   Add some more abbreviation to links

   #+BEGIN_SRC emacs-lisp
     (setq org-link-abbrev-alist
           '(("gmane" . "http://thread.gmane.org/%s")
             ("google" . "https://www.google.com/search?q=%s")
             ("github" . "http://github.com/%s")
             ))
   #+END_SRC


   And some for =org-mode= itself.

   #+BEGIN_SRC emacs-lisp
     ;; from http://endlessparentheses.com/use-org-mode-links-for-absolutely-anything.html
     (org-add-link-type
      "tag" 'endless/follow-tag-link)

     (defun endless/follow-tag-link (tag)
       "Display a list of TODO headlines with tag TAG.
     With prefix argument, also display headlines without a TODO keyword."
       (org-tags-view (null current-prefix-arg) tag))
   #+END_SRC


** Code blocks

   We are using a lot of code block in org-mode, in this file for example ; let's
   /fontify/ the code blocks first.

   #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively t)
      (org-babel-do-load-languages
       'org-babel-load-languages
       '( (perl . t)
          (ruby . t)
          (sh . t)
          (python . t)
          (emacs-lisp . t)
          ;; (golang . t)
          (haskell . t)
          (ditaa . t)
          ))
   #+END_SRC

   Add a function to easily add a code block and bind it.

   #+BEGIN_SRC emacs-lisp
      (defun my/org-insert-src-block (src-code-type)
        "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
        (interactive
         (let ((src-code-types
                '("emacs-lisp" "python" "C" "sh" "java" "js" "clojure" "C++" "css"
                  "calc" "dot" "gnuplot" "ledger" "R" "sass" "screen" "sql" "awk"
                  "ditaa" "haskell" "latex" "lisp" "matlab" "org" "perl" "ruby"
                  "sqlite" "rust" "scala" "golang" "restclient")))
           (list (ido-completing-read "Source code type: " src-code-types))))
        (progn
          (newline-and-indent)
          (insert (format "#+BEGIN_SRC %s\n" src-code-type))
          (newline-and-indent)
          (insert "#+END_SRC\n")
          (previous-line 2)
          (org-edit-src-code)))

      (defun my/org-insert-html-block ()
        "Insert a `HTML-BLOCK` type in org-mode."
        (interactive
         (progn
           (newline-and-indent)
           (insert "#+BEGIN_HTML\n")
           (newline-and-indent)
           (insert "#+END_HTML\n")
           (previous-line 2))))


      (defun my/org-insert-blockquote-block ()
        "Insert a `BLOCKQUOTE-BLOCK` type in org-mode."
        (interactive
         (progn
           (newline-and-indent)
           (insert "#+BEGIN_BLOCKQUOTE\n")
           (newline-and-indent)
           (insert "#+END_BLOCKQUOTE\n")
           (previous-line 2))))



      (add-hook 'org-mode-hook
                '(lambda ()
                   (local-set-key (kbd "C-c s e") 'org-edit-src-code)
                   (local-set-key (kbd "C-c s i") 'my/org-insert-src-block)
                   (local-set-key (kbd "C-c s h") 'my/org-insert-html-block)
                   (local-set-key (kbd "C-c s b") 'my/org-insert-blockquote-block))
                'append)
   #+END_SRC

** Mobile (temporarly disable)

   Define some stuff for the /org-mobile/ synchronization. The
   =org-mobile-directory= is a on a remote ssh, defined in the
   =~/.emacs.d/user.el= file (using =(setq personal-org-mobile-directory "")=).

   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'org-mobile)
     (setq org-mobile-directory personal-org-mobile-directory
           org-mobile-inbox-for-pull (expand-file-name org-inbox-file org-todos-directory)
           org-mobile-files '(org-todos-directory))
   #+END_SRC

   Let's also configure auto push, asynchronously like in this
   [[https://gist.github.com/mrvdb/3111823][gist]]. One thing that I should add though is to auto-commit too
   (because my todos are on git).

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun notify-push (result)
       (notifications-notify
        :title "Push complete"
        :body (format "Org-mobile-push: %s" result)
        ))

     ;; Fork the work of pushing to mobile
     (defun fork-org-push-mobile ()
       (interactive)
       (async-start
        ;; What to do in the child process
        `(lambda ()
           (require 'org)
           ,(async-inject-variables "org-\\(mobile-\\|directory\\)")
           (org-mobile-push))
                                             ; What to do when it finishes
        (lambda (result)
          (notify-push result))))

     ;; Define a timer variable
     (defvar org-mobile-push-timer nil
       "Timer that `org-mobile-push-timer' used to reschedule itself, or nil.")

     ;; Push to mobile when the idle timer runs out
     (defun org-mobile-push-with-delay (secs)
       (when org-mobile-push-timer
         (cancel-timer org-mobile-push-timer))
       (setq org-mobile-push-timer
             (run-with-idle-timer
              (* 1 secs) nil 'fork-org-push-mobile)))

     ;; After saving files, start a 30 seconds idle timer after which we
     ;; are going to push
     (add-hook 'after-save-hook
               (lambda ()
                 (when (eq major-mode 'org-mode)
                   (dolist (file (org-mobile-files-alist))
                     (if (string= (expand-file-name (car file)) (buffer-file-name))
                         (org-mobile-push-with-delay 30)))
                   )))

     ;; At least run it once a day, but no need for a delay this time
     (run-at-time "12:05" 86400 '(lambda () (org-mobile-push-with-delay 1)))
   #+END_SRC


** Archives

   We want to be able to archive some /done/ projects. Let's load
   org-archive and configure it.

   #+BEGIN_SRC emacs-lisp
     (require 'org-archive)
     (setq org-archive-location (concat org-archive-directory org-archive-file-pattern))
   #+END_SRC

** Tags

   Tags should be displayed from the 90 column.

   #+BEGIN_SRC emacs-lisp
     (setq org-tags-column -90)
   #+END_SRC

   Define a list of default tags that should apply for all org-mode
   buffers.

   #+BEGIN_SRC emacs-lisp
     ;; Wish I could use taggroup but it doesn't seem to work..
     (setq org-tag-alist '(
                           ("important" . ?i)
                           ("urgent" . ?u)
                           ("ongoing" . ?o)         ;; ongoing "project", use to filter big project that are on the go
                           ("next" . ?n)            ;; next "project"/"task", use to filter next things to do
                           ("@home" . ?h)           ;; needs to be done at home
                           ("@work" . ?w)           ;; needs to be done at work
                           ("@client" . ?c)         ;; needs to be done at a client place (consulting..)
                           ("dev" . ?e)             ;; this is a development task
                           ("infra" . ?a)           ;; this is a sysadmin/infra task
                           ("document" . ?d)        ;; needs to produce a document (article, post, ..)
                           ("download" . ?D)        ;; needs to download something
                           ("media" . ?m)           ;; this is a media (something to watch, listen, record, ..)
                           ("mail" . ?M)            ;; mail-related (to write & send or to read)
                           ("triage" . ?t)          ;; need "triage", tag it to easily find them
                           ("task" . ?a)            ;; a simple task (no project), the name is kinda misleading
                           ;; docker tags
                           ("docker")
                           ("compose")
                           ("libcompose")
                           ("distribution")
                           ("docs")
                           ("rancher")
                           ;; sites tags
                           ("sites")
                           ("vdf")
                           ("znk")
                           ;; configs tags
                           ("configs")
                           ("emacs")
                           ("i3")
                           ("shell")
                           ;; services
                           ("services")
                           ;; zenika
                           ("znk")
                           ("formation")
                           ("event")
                           ("tribu")
                           ("devops")
                           ("craftmanship")
                           ("client")
                           ))
   #+END_SRC

   Note that =important= and =urgent= helps me prioritize my
   /todos/, in a /quadrant fashion way/.

   | Important          | *Kaizen*        | *Panic*             |
   | /tag important/    | improvements    | emergency           |
   |--------------------+-----------------+---------------------|
   | Less Important     | *Organics*      | Social *investment* |
   | /no tag important/ | inspiration     | Social activities   |
   |--------------------+-----------------+---------------------|
   |                    | Less Urgent     | Urgent              |
   |                    | /no tag urgent/ | /tag urgent/        |


** Agenda(s)

   Set custom agendas.. For the syntax, look in worg : [[http://orgmode.org/worg/org-tutorials/advanced-searching.html][Advanced
   searching]] and [[http://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][Custom Agenda Commands]].

   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-custom-commands
           '(("t" todo "TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("p" todo "PROGRESS"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("r" todo "REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("a" todo "PAUSED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("b" todo "BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("o" "Ongoing projects" tags-todo "ongoing"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-tags-exclude-from-inheritance '("ongoing"))
               (org-agenda-prefix-format "  Mixed: ")))
             ("n" "Next tasks" tags-todo "next"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-tags-exclude-from-inheritance '("next"))
               (org-agenda-prefix-format "  Mixed: ")))
             ("i" "Triage tasks â€” to look" tags-todo "triage"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ;; Timelines
             ("d" "Timeline for today" ((agenda "" ))
              ((org-agenda-ndays 1)
               (org-agenda-show-log t)
               (org-agenda-log-mode-items '(clock closed))
               (org-agenda-clockreport-mode t)
               (org-agenda-entry-types '())))
             ("w" "Weekly review" agenda ""
              ((org-agenda-span 7)
               (org-agenda-log-mode 1)))
             ("W" "Weekly review sans DAILY" agenda ""
              ((org-agenda-span 7)
               (org-agenda-log-mode 1)
               (org-agenda-tag-filter-preset '("-DAILY"))))
             ("2" "Bi-weekly review" agenda "" ((org-agenda-span 14) (org-agenda-log-mode 1)))
             ;; Panic tasks : urgent & important
             ;; Probably the most important to do, but try not have to much of them..
             ("P" . "Panic -emergency-")
             ("Pt" "TODOs" tags-todo "important&urgent/!TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Pb" "BLOCKEDs" tags-todo "important&urgent/!BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Pr" "REVIEWs" tags-todo "important&urgent/!REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ;; Kaizen tasks : important but not urgent
             ("K" . "Kaizen -improvement-")
             ("Kt" "TODOs" tags-todo "important&-urgent/!TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Kb" "BLOCKEDs" tags-todo "important&-urgent/!BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Kr" "REVIEWs" tags-todo "important&-urgent/!REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ;; Social investment : urgent
             ("S" . "Social -investment-")
             ("St" "TODOs" tags-todo "-important&urgent/!TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Sb" "BLOCKEDs" tags-todo "-important&urgent/!BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Sr" "REVIEWs" tags-todo "-important&urgent/!REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ;; Organics
             ("O" . "Organics -inspiration-")
             ("Ot" "TODOs" tags-todo "-important&-urgent/!TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Ob" "BLOCKEDs" tags-todo "-important&-urgent/!BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Or" "REVIEWs" tags-todo "-important&-urgent/!REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("N" search ""
              ((org-agenda-files '("~org/notes.org"))
               (org-agenda-text-search-extra-files nil)))))
   #+END_SRC

** Pomodoro

   #+BEGIN_SRC emacs-lisp
     (use-package org-pomodoro
       :ensure t
       :init
       (setq org-pomodoro-play-sounds 1)
       (setq org-pomodoro-audio-player "paplay"))
   #+END_SRC

** Publishing

   Let's configure the publishing part of org-mode. The first
   org-mode files we want to publish are in =~/desktop/org/sites/{project}=,
   and we want to publish them in =~/var/public_html/{project}= for
   now.

   Few org-export and org-html configuration.

   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :ensure t
       :defer t)
     ;;      (setq org-html-head "<link rel=\"stylesheet\" type=\"text/css\" hrefl=\"css/stylesheet.css\" />")
     (setq org-html-include-timestamps nil)
     ;; (setq org-html-htmlize-output-type 'css)
     (setq org-html-head-include-default-style nil)
   #+END_SRC

   And the projects.

   #+BEGIN_SRC emacs-lisp
     (use-package ox-publish)
     ;; (use-package ox-rss)

     (setq org-html-html5-fancy t)

     ;; Define some variables to write less :D
     (setq sbr-base-directory (expand-file-name "sbr" org-sites-directory)
           sbr-publishing-directory (expand-file-name "sbr" org-publish-folder)
           znk-base-directory (expand-file-name "zenika" org-sites-directory)
           znk-preview-publishing-directory (expand-file-name "zenika" org-publish-folder)
           znk-publishing-directory (expand-file-name "zenika-export" org-publish-folder)
           vdf-base-directory (expand-file-name "vdf" org-sites-directory)
           vdf-site-directory (expand-file-name "blog" sites-folder)
           vdf-publishing-directory (expand-file-name "posts" (expand-file-name "content" vdf-site-directory))
           vdf-static-directory (expand-file-name "static" vdf-site-directory)
           vdf-css-publishing-directory (expand-file-name "css" vdf-static-directory)
           vdf-assets-publishing-directory vdf-static-directory)

     ;; Project
     (setq org-publish-project-alist
           `(("sbr-notes"
              :base-directory ,sbr-base-directory
              :base-extension "org"
              :publishing-directory ,sbr-publishing-directory
              :makeindex t
              :exclude "FIXME"
              :recursive t
              :htmlized-source t
              :publishing-function org-html-publish-to-html
              :headline-levels 4
              :auto-preamble t
              :html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" />"
              :html-preamble "<div id=\"nav\">
     <ul>
     <li><a href=\"/\" class=\"home\">Home</a></li>
     </ul>
     </div>"
              :html-postamble "<div id=\"footer\">
     %a %C %c
     </div>")
             ("sbr-static"
              :base-directory ,sbr-base-directory
              :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg"
              :publishing-directory ,sbr-publishing-directory
              :recursive t
              :publishing-function org-publish-attachment
              )
             ("sbr" :components ("sbr-notes" "sbr-static"))
             ("vdf-notes"
              :base-directory ,vdf-base-directory
              :base-extension "org"
              :publishing-directory ,vdf-publishing-directory
              :exclude "FIXME"
              :section-numbers nil
              :with-toc nil
              :with-drawers t
              :htmlized-source t
              :html-html5-fancy t
              :publishing-function org-html-publish-to-html
              :headline-levels 4
              :body-only t)
             ("vdf-static-css"
              :base-directory ,vdf-base-directory
              :base-extension "css"
              :publishing-directory ,vdf-css-publishing-directory
              :recursive t
              :publishing-function org-publish-attachment
              )
             ("vdf-static-assets"
              :base-directory ,vdf-base-directory
              :base-extension "png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg"
              :publishing-directory ,vdf-assets-publishing-directory
              :recursive t
              :publishing-function org-publish-attachment
              )
             ("vdf" :components ("vdf-notes" "vdf-static-css" "vdf-static-assets"))
             ("znk-notes"
              :base-directory ,znk-base-directory
              :base-extension "org"
              :publishing-directory ,znk-publishing-directory
              :exclude "FIXME"
              :section-numbers nil
              :with-toc nil
              :with-drawers t
              :recursive t
              :htmlized-source t
              :publishing-function org-html-publish-to-html
              :headline-levels 4
              :body-only t)
             ("znk-notes-previews"
              :base-directory ,znk-base-directory
              :base-extension "org"
              :publishing-directory ,znk-preview-publishing-directory
              :makeindex t
              :exclude "FIXME"
              :recursive t
              :htmlized-source t
              :publishing-function org-html-publish-to-html
              :headline-levels 4
              :auto-preamble t
              :html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" />"
              :html-preamble "<div id=\"nav\">
     <ul>
     <li><a href=\"/\" class=\"home\">Home</a></li>
     </ul>
     </div>"
              :html-postamble "<div id=\"footer\">
     %a %C %c
     </div>")
             ("znk-static"
              :base-directory ,znk-base-directory
              :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg"
              :publishing-directory ,znk-publishing-directory
              :recursive t
              :publishing-function org-publish-attachment
              )
             ("znk" :components ("znk-notes" "znk-notes-previews" "znk-static"))
             ))
   #+END_SRC

   Now, I also want to use =org-mode= for some of my talks (if not
   all), and [[https://github.com/coldnew/org-ioslide][=org-ioslide=]] looks pretty good.


   #+BEGIN_SRC emacs-lisp
     (use-package ox-ioslide
       :ensure t)
   #+END_SRC


** Protocol

   Trying out org-protocol based on
   http://oremacs.com/2015/01/07/org-protocol-1/ and
   http://oremacs.com/2015/01/08/org-protocol-2/.


   #+BEGIN_SRC emacs-lisp
     (use-package org-capture)
     (use-package org-protocol)
     (setq org-protocol-default-template-key "l")
     (push '("l" "Link" entry (function org-handle-link)
             "* TODO %(org-wash-link)\nAdded: %U\n%(org-link-hooks)\n%?")
           org-capture-templates)

     (defun org-wash-link ()
       (let ((link (caar org-stored-links))
             (title (cadar org-stored-links)))
         (setq title (replace-regexp-in-string
                      " - Stack Overflow" "" title))
         (org-make-link-string link title)))

     (defvar org-link-hook nil)

     (defun org-link-hooks ()
       (prog1
           (mapconcat #'funcall
                      org-link-hook
                      "\n")
         (setq org-link-hook)))

     (defun org-handle-link ()
       (let ((link (caar org-stored-links))
             file)
         (cond ((string-match "^https://www.youtube.com/" link)
                (org-handle-link-youtube link))
               ((string-match (regexp-quote
                               "http://stackoverflow.com/") link)
                (find-file ((expand-file-name org-stackoverflow-file org-notes-directory)))
                (goto-char (point-min))
                (re-search-forward "^\\*+ +Questions" nil t))
               (t
                (find-file ((expand-file-name org-web-article-file org-notes-directory)))
                (goto-char (point-min))
                (re-search-forward "^\\*+ +Articles" nil t)))))

     (defun org-handle-link-youtube (link)
       (lexical-let*
           ((file-name (org-trim
                        (shell-command-to-string
                         (concat
                          "youtube-dl \""
                          link
                          "\""
                          " -o \"%(title)s.%(ext)s\" --get-filename"))))
            (dir videos-folder)
            (full-name
             (expand-file-name file-name dir)))
         (add-hook 'org-link-hook
                   (lambda ()
                     (concat
                      (org-make-link-string dir dir)
                      "\n"
                      (org-make-link-string full-name file-name))))
         (async-shell-command
          (format "youtube-dl \"%s\" -o \"%s\"" link full-name))
         (find-file (org-expand "ent.org"))
         (goto-char (point-min))
         (re-search-forward "^\\*+ +videos" nil t)))
   #+END_SRC

** Some bindings

   Add some bindings that wouldn't have been defined before. This should
   be a bit rework.

   #+BEGIN_SRC emacs-lisp
     (defun org-open-main-org-file ()
       "Open the main org-mode file (where lies all my things"
       (interactive)
       (find-file (expand-file-name org-main-file org-todos-directory)))
     (defun org-open-notes-folder ()
       "Open the notes folder"
       (interactive)
       (find-file org-notes-directory))

     (use-package org
       :ensure org
       :bind* (("M-m o a"   . org-agenda)
               ("M-m o c"   . org-capture)
               ("M-m o i"   . org-insert-link)
               ("M-m o s"   . org-store-link)
               ("M-m o S"   . org-list-make-subtree)
               ("M-m o A"   . org-archive-subtree)
               ("M-m o g"   . org-goto)
               ("M-m o L"   . org-toggle-link-display)
               ("M-m o I"   . org-toggle-inline-images)
               ("M-m o k"   . org-cut-subtree)
               ("M-m o R"   . org-refile)
               ("M-m o y"   . org-copy-subtree)
               ("M-m o h"   . org-toggle-heading)
               ("M-m o e"   . org-export-dispatch)
               ("M-m o u"   . org-update-dblock)
               ("M-m o U"   . org-update-all-dblocks)
               ("M-m o O"   . org-footnote)
               ("M-m o N"   . org-add-note)
               ("M-m o E"   . org-set-effort)
               ("M-m o B"   . org-table-blank-field)
               ("M-m o <"   . org-date-from-calendar)
               ("M-m o >"   . org-goto-calendar)
               ("M-m a s"   . org-mark-subtree)
               ("M-m o RET" . org-open-at-point)
               ("M-m o p"   . org-open-main-file)
               ("M-m o n"   . org-open-notes-folder)))
     (which-key-add-key-based-replacements
       "M-m o" "org mode prefix")
   #+END_SRC

** Hydras
*** Organize trees

    This is to rearrange sub trees, reorder them, promote, demote and cycle through TODOs.

    #+BEGIN_SRC emacs-lisp
      (defhydra sk/hydra-org-organize (:color red
                                              :hint nil)
        "
             ^Meta^    ^Shift^   ^Shift-Meta^ ^Shift-Ctrl^  ^Move^        ^Item^
            ^^^^^^^^^^^^^--------------------------------------------------------------------
             ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   ^ ^ _p_ ^ ^      ^ ^ _P_ ^ ^       _<_: promote  _u_: up     _q_: quit
             _h_ ^+^ _l_   _H_ ^+^ _L_   _b_ ^+^ _f_      _B_ ^+^ _F_       _>_: demote   _d_: down
             ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   ^ ^ _n_ ^ ^      ^ ^ _N_ ^ ^
            "
        ("h" org-metaleft)
        ("l" org-metaright)
        ("j" org-metadown)
        ("k" org-metaup)
        ("H" org-shiftleft)
        ("L" org-shiftright)
        ("J" org-shiftdown)
        ("K" org-shiftup)
        ("b" org-shiftmetaleft)
        ("f" org-shiftmetaright)
        ("n" org-shiftmetadown)
        ("p" org-shiftmetaup)
        ("B" org-shiftcontrolleft)
        ("F" org-shiftcontrolright)
        ("P" org-shiftcontroldown)
        ("N" org-shiftcontrolup)
        ("<" org-promote)
        (">" org-demote)
        ("d" org-move-item-down)
        ("u" org-move-item-up)
        ("q" nil :color blue))
      (bind-keys*
       ("M-m o o" . sk/hydra-org-organize/body))
    #+END_SRC

*** Task management

    As mentioned [[*Task management][before]], Org is amazing for TODO lists and has the ability to schedule deadlines too.

    #+BEGIN_SRC emacs-lisp
      (defhydra sk/hydra-org-todo (:color red
                                          :hint nil)
        "
       _d_: deadline    _o_: over    _s_: schedule   _c_: check   _q_: quit
      "
        ("d" org-deadline :color blue)
        ("o" org-deadline-close :color blue)
        ("s" org-schedule :color blue)
        ("c" org-check-deadlines)
        ("q" nil :color blue))
      (bind-keys*
       ("M-m o D" . sk/hydra-org-todo/body))
    #+END_SRC

*** Check boxes

    [[http://orgmode.org/manual/Checkboxes.html][Org supports checkboxes]] and my configuration should too.

    #+BEGIN_SRC emacs-lisp
      (defhydra sk/hydra-org-checkbox (:color pink
                                              :hint nil)
        "
       _t_: toggle   _s_: stats    _r_: reset    _c_: count    _q_: quit
      "
        ("t" org-toggle-checkbox)
        ("c" org-update-checkbox-count-maybe)
        ("r" org-reset-checkbox-state-subtree)
        ("s" org-update-statistics-cookies)
        ("q" nil :color blue))
      (bind-keys*
       ("M-m o b" . sk/hydra-org-checkbox/body))
    #+END_SRC

*** Properties

    [[http://orgmode.org/manual/Properties-and-Columns.html][Org properties]] are really good places to have meta data. Although I personally don't create many properties manually, it is useful to have this functionality around.

    #+BEGIN_SRC emacs-lisp
      (defhydra sk/hydra-org-property (:color red
                                              :hint nil)
        "
       _i_: insert  _p_: property   _s_: set    _d_: delete    _t_: toggle    _q_: quit
      "
        ("i" org-insert-drawer)
        ("p" org-insert-property-drawer)
        ("s" org-set-property)
        ("d" org-delete-property)
        ("t" org-toggle-ordered-property)
        ("q" nil :color blue))

      (bind-keys*
       ("M-m o P" . sk/hydra-org-property/body))
    #+END_SRC

*** Clocking functionality

    [[http://orgmode.org/manual/Clocking-work-time.html][Of course, Org mode has clocking functionality]].

    #+BEGIN_SRC emacs-lisp
      (defhydra sk/hydra-org-clock (:color red
                                           :hint nil)
        "
       ^Clock^                     ^Timer^     ^Stamp^
      ^^^^^^^^^^-------------------------------------------------
       _i_: in       _z_: resolve    _b_: begin  _t_: stamp       _q_: quit
       _o_: out      _l_: last       _e_: end    _u_: inactive
       _r_: report   _c_: cancel     _m_: timer
       _d_: display  _g_: goto       _s_: set
      "
        ("i" org-clock-in)
        ("o" org-clock-out)
        ("r" org-clock-report)
        ("z" org-resolve-clocks)
        ("c" org-clock-cancel)
        ("d" org-clock-display)
        ("l" org-clock-in-last)
        ("g" org-clock-goto)
        ("m" org-timer)
        ("s" org-timer-set-timer)
        ("b" org-timer-start)
        ("e" org-timer-stop)
        ("t" org-time-stamp)
        ("u" org-time-stamp-inactive)
        ("q" nil :color blue))
      (bind-keys*
       ("M-m o C" . sk/hydra-org-clock/body))
    #+END_SRC

*** Table manipulation

    Org mode can create [[http://orgmode.org/manual/Tables.html][tables]] with [[http://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html][spreadsheet capabilities]].

    #+BEGIN_SRC emacs-lisp
      (defhydra sk/hydra-org-tables (:color red
                                            :hint nil)
        "
       ^Field^   ^Shift^   ^Insert^      ^Delete^         ^Field^     ^Table^      ^Formula^
      ^^^^^^^^^^^^------------------------------------------------------------------------------
       ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   _r_: row      _dr_: del row    _e_: edit   _a_: align   _+_: sum    _q_: quit
       _h_ ^+^ _l_   _H_ ^+^ _L_   _c_: column   _dc_: del col    _b_: blank  _|_: create  _=_: eval
       ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   _-_: hline                   _i_: info             _f_: edit
      "
        ("a" org-table-align)
        ("l" org-table-next-field)
        ("h" org-table-previous-field)
        ("j" org-table-end-of-field)
        ("k" org-table-beginning-of-field)
        ("r" org-table-insert-row)
        ("c" org-table-insert-column)
        ("-" org-table-insert-hline)
        ("J" org-table-move-row-down)
        ("K" org-table-move-row-up)
        ("H" org-table-move-column-left)
        ("L" org-table-move-column-right)
        ("dr" org-table-kill-row)
        ("dc" org-table-delete-column)
        ("b" org-table-blank-field)
        ("e" org-table-edit-field)
        ("i" org-table-field-info)
        ("+" org-table-sum)
        ("=" org-table-eval-formula)
        ("f" org-table-edit-formulas)
        ("|" org-table-create-or-convert-from-region)
        ("q" nil :color blue))
      (bind-keys*
       ("M-m o m" . sk/hydra-org-tables/body))
    #+END_SRC

*** Jump

    This is a massively useful hydra to move around in an org file

    #+BEGIN_SRC emacs-lisp
      (defhydra sk/hydra-org-jump (:color pink
                                          :hint nil)
        "
       ^Outline^          ^Item^   ^Table^   ^Block^   ^Link^
       ^^^^^^^^^^^-------------------------------------------------------------------------------
       ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   ^ ^ _u_ ^ ^   ^ ^ ^ ^ ^ ^   ^ ^ _p_ ^ ^   ^ ^ _P_ ^ ^    _q_ quit
       _h_ ^+^ _l_   ^ ^ ^+^ ^ ^   ^ ^ ^+^ ^ ^   _b_ ^+^ _f_   ^ ^ ^+^ ^ ^   ^ ^ ^+^ ^ ^
       ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   ^ ^ _d_ ^ ^   ^ ^ ^ ^ ^ ^   ^ ^ _n_ ^ ^   ^ ^ _N_ ^ ^
      "
        ("j" outline-next-visible-heading)
        ("k" outline-previous-visible-heading)
        ("l" org-down-element)
        ("h" org-up-element)
        ("J" org-forward-heading-same-level)
        ("K" org-backward-heading-same-level)
        ("u" org-next-item)
        ("d" org-previous-item)
        ("f" org-table-next-field)
        ("b" org-table-previous-field)
        ("n" org-next-block)
        ("p" org-previous-block)
        ("N" org-next-link)
        ("P" org-previous-link)
        ("q" nil :color blue))
      (bind-keys*
       ("M-m o j" . sk/hydra-org-jump/body))
    #+END_SRC
*** Agenda view

    The agenda menu already has a built-in agenda view but I always forget the keys. So, I need some reminding

    #+BEGIN_SRC emacs-lisp
      (defhydra sk/hydra-org-agenda-view (:color red
                                                 :hint nil)
        "
       _d_: day        _g_: time grid    _a_: arch-trees    _L_: log closed clock
       _w_: week       _i_: inactive     _A_: arch-files    _c_: log clock check
       _t_: fortnight  _f_: follow       _r_: report        _l_: log mode toggle
       _m_: month      _e_: entry        _D_: diary         _q_: quit
       _y_: year       _!_: deadlines    _R_: reset
      "
        ("R" org-agenda-reset-view)
        ("d" org-agenda-day-view)
        ("w" org-agenda-week-view)
        ("t" org-agenda-fortnight-view)
        ("m" org-agenda-month-view)
        ("y" org-agenda-year-view)
        ("l" org-agenda-log-mode)
        ("L" (org-agenda-log-mode '(4)))
        ("c" (org-agenda-log-mode 'clockcheck))
        ("f" org-agenda-follow-mode)
        ("a" org-agenda-archives-mode)
        ("A" (org-agenda-archives-mode 'files))
        ("r" org-agenda-clockreport-mode)
        ("e" org-agenda-entry-text-mode)
        ("g" org-agenda-toggle-time-grid)
        ("D" org-agenda-toggle-diary)
        ("!" org-agenda-toggle-deadlines)
        ("i"
         (let ((org-agenda-include-inactive-timestamps t))
           (org-agenda-check-type t 'timeline 'agenda)
           (org-agenda-redo)))
        ("q" nil :color blue))
      (bind-keys*
       ("M-m o v" . sk/hydra-org-agenda-view/body))
    #+END_SRC

* Version control ðŸ¹
** Magit

   [[https://magit.vc][The best interface to Git ever]]. Enough said.

   #+BEGIN_SRC emacs-lisp
       (use-package magit
         :ensure t
         :commands magit-status
         :bind ("C-c g" . magit-status)
         :config
         (setq magit-completing-read-function 'ivy-completing-read)
         (add-to-list 'magit-no-confirm 'stage-all-changes)
         (setq magit-push-always-verify nil)
         (setq magit-last-seen-setup-instructions "2.1.0"))
   #+END_SRC
** Highlight diffs

   [[https://github.com/dgutov/diff-hl][Highlight git diffs on the fly]].

   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :ensure t
       :commands (global-diff-hl-mode
                  diff-hl-mode
                  diff-hl-next-hunk
                  diff-hl-previous-hunk
                  diff-hl-mark-hunk
                  diff-hl-diff-goto-hunk
                  diff-hl-revert-hunk)
       :bind* (("M-m ] h" . diff-hl-next-hunk)
               ("M-m [ h" . diff-hl-previous-hunk)
               ("M-m i h" . diff-hl-mark-hunk)
               ("M-m a h" . diff-hl-mark-hunk)
               ("M-m g h" . diff-hl-diff-goto-hunk)
               ("M-m g H" . diff-hl-revert-hunk))
       :config
       (global-diff-hl-mode)
       (diff-hl-flydiff-mode)
       (diff-hl-margin-mode)
       (diff-hl-dired-mode))
   #+END_SRC

** Git time machine

   The ability to move to past versions of the current file, [[https://github.com/pidu/git-timemachine][like a time machine]].

   #+BEGIN_SRC emacs-lisp
     (use-package git-timemachine
       :ensure t
       :commands (git-timemachine-toggle
                  git-timemachine-switch-branch)
       :bind* (("M-m g l" . git-timemachine-toggle)
               ("M-m g L" . git-timemachine-switch-branch)))
   #+END_SRC

** Git annex support

   [[http://git-annex.branchable.com/][Git-annex]] is a wonderful piece of software that I use a lot in my repositories.

   #+BEGIN_QUOTE
   git-annex allows managing files with git, without checking the file contents into git. While that may seem paradoxical, it is useful when dealing with files larger than git can currently easily handle, whether due to limitations in memory, time, or disk space.
   #+END_QUOTE

   In Emacs, it integrates with magit and dired mode. The annex subcommand for magit is ~@~.

   #+BEGIN_SRC emacs-lisp
     (use-package git-annex
       :ensure t)
     (use-package magit-annex
       :ensure t)
   #+END_SRC

** Gists

   [[https://help.github.com/articles/about-gists/][Gists]] is a nice feature of GitHub to share code easily. [[https://github.com/mhayashi1120/yagist.el][This package]] makes it easy to post code into a Gist.

   #+BEGIN_SRC emacs-lisp
     (use-package yagist
       :ensure t
       :commands (yagist-region-or-buffer
                  yagist-region-or-buffer-private)
       :bind* (("M-m g p" . yagist-region-or-buffer)
               ("M-m g P" . yagist-region-or-buffer-private))
       :init
       (setq yagist-encrypt-risky-config t))
   #+END_SRC

** Browse remote files

   [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] is a very handy package to view the file/region on the actual Github/Gitlab/Bitbucket page.

   #+BEGIN_SRC emacs-lisp
     (use-package browse-at-remote
       :ensure f
       :bind* (("M-m g i" . browse-at-remote)))
   #+END_SRC

   /Note: it does work as of today, I'll look into it why../

* Programming âŒ¨
** Auto completion

   #+BEGIN_QUOTE
   Company is a text completion framework for Emacs. The name stands
   for "complete anything". It uses pluggable back-ends and front-ends
   to retrieve and display completion candidates.
   #+END_QUOTE


   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :commands (company-mode
                  company-complete
                  company-complete-common
                  company-complete-common-or-cycle
                  company-files
                  company-dabbrev
                  company-ispell
                  company-c-headers
                  company-elisp)
       :init
       (setq company-minimum-prefix-length 2)
       (setq company-tooltip-limit 20)                      ; bigger popup window
       (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
       (setq company-echo-delay 0)                          ; remove annoying blinking
       (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
       :bind (("M-t"   . company-complete)
              ("C-c f" . company-files)
              ("C-c a" . company-dabbrev)
              ("C-c d" . company-ispell)
              :map company-active-map
              ("C-n"    . company-select-next)
              ("C-p"    . company-select-previous)
              ([return] . company-complete-selection)
              ("C-w"    . backward-kill-word)
              ("C-c"    . company-abort)
              ("C-c"    . company-search-abort))
       :diminish (company-mode . "Ï‚")
       :config
       (add-hook 'after-init-hook 'global-company-mode)
       (use-package company-quickhelp
         :ensure t
         :config
         (company-quickhelp-mode)))
   #+END_SRC


** Eshell

   Eshell is a built-in shell that is written in Lisp. It's pretty good.

   #+BEGIN_SRC emacs-lisp
     (use-package eshell
       :commands (eshell)
       :bind* (("M-m SPC s" . sk/eshell-vertical)
               ("M-m SPC S" . sk/eshell-horizontal))
       :init
       (setq eshell-glob-case-insensitive t
             eshell-scroll-to-bottom-on-input 'this
             eshell-buffer-shorthand t
             eshell-history-size 1024
             eshell-cmpl-ignore-case t
             eshell-aliases-file (concat user-emacs-directory ".eshell-aliases")
             eshell-last-dir-ring-size 512)
       :config
       (add-hook 'shell-mode-hook 'goto-address-mode))
   #+END_SRC

   Let's also define a couple of functions to open it in a vertical or horizontal split.

   #+BEGIN_SRC emacs-lisp
     ;; Vertical split eshell
     (defun sk/eshell-vertical ()
       "opens up a new shell in the directory associated with the current buffer's file."
       (interactive)
       (let* ((parent (if (buffer-file-name)
                          (file-name-directory (buffer-file-name))
                        default-directory))
              (name (car (last (split-string parent "/" t)))))
         (split-window-right)
         (other-window 1)
         (eshell "new")
         (rename-buffer (concat "*eshell: " name "*"))
         (eshell-send-input)))

     ;; Horizontal split eshell
     (defun sk/eshell-horizontal ()
       "opens up a new shell in the directory associated with the current buffer's file."
       (interactive)
       (let* ((parent (if (buffer-file-name)
                          (file-name-directory (buffer-file-name))
                        default-directory))
              (name (car (last (split-string parent "/" t)))))
         (split-window-below)
         (other-window 1)
         (eshell "new")
         (rename-buffer (concat "*eshell: " name "*"))
         (eshell-send-input)))
   #+END_SRC

   let's kill the buffer on exit.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'shell-mode-hook 'wcy-shell-mode-hook-func)
     (defun wcy-shell-mode-hook-func  ()
       (set-process-sentinel (get-buffer-process (current-buffer))
                             #'shell-mode-kill-buffer-on-exit)
       )
     (defun shell-mode-kill-buffer-on-exit (process state)
       (message "%s" state)
       (if (or
            (string-match "exited abnormally with code.*" state)
            (string-match "finished" state))
           (kill-buffer (current-buffer))))
   #+END_SRC

** Multi term

   [[https://www.emacswiki.org/emacs/MultiTerm][Multi term]] doesn't provide any additional commands to built-in Emacs
   ~term~ and ~ansi-term~ but helps in managing multiple terminal
   buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package multi-term
       :ensure t
       :commands (multi-term)
       :bind* (("M-m SPC u" . sk/multi-term-vertical)
               ("M-m SPC U". sk/multi-term-horizontal)))
   #+END_SRC

   Let's also define a couple of wrapper functions to open this in
   splits.

   #+BEGIN_SRC emacs-lisp
     ;; Vertical split multi-term
     (defun sk/multi-term-vertical ()
       "opens up a new terminal in the directory associated with the current buffer's file."
       (interactive)
       (split-window-right)
       (other-window 1)
       (multi-term))

     ;; Horizontal split multi-term
     (defun sk/multi-term-horizontal ()
       "opens up a new terminal in the directory associated with the current buffer's file."
       (interactive)
       (split-window-below)
       (other-window 1)
       (multi-term))
   #+END_SRC

** Compilation buffer

   Let's configure the compilation-mode to follow the compilation, not waiting
   at the top..

   #+BEGIN_SRC emacs-lisp
     (setq compilation-scroll-output t)
     ;; I'm not scared of saving everything.
     (setq compilation-ask-about-save nil)
     ;; Stop on the first error.
     (setq compilation-scroll-output 'next-error)
     ;; Don't stop on info or warnings.
     (setq compilation-skip-threshold 2)
   #+END_SRC

   Let's also colorize the output if possible (because why not :D) â€”
   [[http://stackoverflow.com/questions/3072648/cucumbers-ansi-colors-messing-up-emacs-compilation-buffer][stackoverflow thread]].

   #+BEGIN_SRC emacs-lisp
     (require 'ansi-color)
     (defun my/colorize-compilation-buffer ()
       (toggle-read-only)
       (ansi-color-apply-on-region (point-min) (point-max))
       (toggle-read-only))
     (add-hook 'compilation-filter-hook 'my/colorize-compilation-buffer)
   #+END_SRC

** Quickrun

   [[https://github.com/syohex/emacs-quickrun][This package]] helps you quickly run little pieces of code.

   #+BEGIN_SRC emacs-lisp
     (use-package quickrun
       :ensure t
       :commands (quickrun
                  quickrun-region
                  quickrun-with-arg
                  quickrun-shell
                  quickrun-compile-only
                  quickrun-replace-region))
   #+END_SRC
** Error checking

   #+BEGIN_QUOTE
   Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs 24, intended as replacement for the older Flymake extension which is part of GNU Emacs.

   It uses various syntax checking and linting tools to check the contents of buffers, and reports warnings and errors directly in the buffer, or in an optional error list.
   #+END_QUOTE

   Let's install it and configure it for the common part. The language
   specifics will be defined in the corresponding language section.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :diminish flycheck-mode
       :config
       (progn
         (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
         (setq flycheck-indication-mode 'right-fringe)
         (add-hook 'after-init-hook #'global-flycheck-mode)))
   #+END_SRC
** Editorconfig

   [[http://editorconfig.org][Editorconfig]] is a small utility that is helpful in keeping the code
   clean as it takes care of the necessary indentation and can be used
   across editors.

   #+BEGIN_SRC emacs-lisp
     (use-package editorconfig
       :ensure t
       :demand t
       :config
       (editorconfig-mode 1))
   #+END_SRC

** Markdown and Pandoc support

   Although I use Org for most of my markup documentation and it has an
   export function to markdown, these packages give better support. So,
   why not install them.

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t
       :mode ("\\.markdown\\'" "\\.mkd\\'" "\\.md\\'")
       :config
       (use-package pandoc-mode
         :ensure t
         :mode ("\\.markdown\\'" "\\.mkd\\'" "\\.md\\'")))
   #+END_SRC

** YAML mode

   YAML is a plain text file format used by many places to specify meta
   data. This provides some syntax highlighting for that.

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t
       :mode "\\.yml$")
   #+END_SRC

** TOML mode

   TOML is yet another plain text file format used by many places to
   specify configuration. This provides some syntax highlighting for
   that.

   #+BEGIN_SRC emacs-lisp
     (use-package toml-mode
       :ensure t)
   #+END_SRC

** Lisp

   Let's install some modes that proves to be useful for any LISP.

   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :ensure t)
     (use-package rainbow-mode
       :ensure t)
     (use-package rainbow-delimiters
       :ensure t)
     (use-package highlight-parentheses
       :ensure t)
   #+END_SRC

   And define a comme lisp hook for all LISP-related prog-modes, mostly about
   parentheses.

   #+BEGIN_SRC emacs-lisp
     (defun my/lisps-mode-hook ()
       (paredit-mode t)
       (rainbow-delimiters-mode t)
       (highlight-parentheses-mode t)
       )
   #+END_SRC

*** Emacs Lisp

    Let's enable common LISP mode hook and =eldoc= too.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'emacs-lisp-mode-hook
                (lambda ()
                  (my/lisps-mode-hook)
                  (eldoc-mode 1))
                )
    #+END_SRC

** SQL

   Emacs is really more than an editor. The SQL mode is quick and cool to
   used (and do not eat my memory like mysql-workbench for
   example).

   By default, Emacs does not automatically truncate long lines in
   SQL(i) mode, let's change that.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'sql-interactive-mode-hook
               (lambda ()
                 (toggle-truncate-lines t)))
   #+END_SRC
** Docker ðŸ³

   I'm playing a lot with [[http://docker.com][docker]] and most of the time editing
   Dockerfile and stuff inside Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :ensure t)
   #+END_SRC

** Restclient

   Soâ€¦ I needed to hack a bit around the [[https://docker.com][Docker]] client API and wanted
   to do this in Emacs (why not =:-)=). And well [[https://github.com/pashky/restclient.el][restclient.el]] is
   pretty awesome.

   #+BEGIN_SRC emacs-lisp
     (use-package restclient
       :ensure t)
     (use-package ob-restclient
       :ensure t
       :config
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((restclient . t))))
   #+END_SRC

** Nix related modes

   #+BEGIN_QUOTE
   NixOS is a Linux distribution with a unique approach to package and
   configuration management. Built on top of the Nix package manager, it
   is completely declarative, makes upgrading systems reliable, and has
   many other advantages.
   #+END_QUOTE

*** Nix mode

    This mode provides syntax highlighting to nix files.

    #+BEGIN_SRC emacs-lisp
      (use-package nix-mode
        :ensure t)
    #+END_SRC

*** Company backend

    #+BEGIN_SRC emacs-lisp
      (use-package company-nixos-options
        :ensure t
        :config
        (add-to-list 'company-backends 'company-nixos-options))
    #+END_SRC

*** Nixos-sandbox

    These are utilies funtions to work with nix sandboxes.

    #+BEGIN_SRC emacs-lisp
      (use-package nix-sandbox
        :ensure t)
    #+END_SRC

* Provided configuration

  I'm managing my configurations using [[https://github.com/RichiH/vcsh][vcsh]] and [[http://myrepos.branchable.com/][myrepos]], like [[https://github.com/vdemeester/vcsh-home#how-it-is-supposed-to-work][that]]. I have a lot
  of different configuration repository ([[https://github.com/search?q%3Duser%253Avdemeester%2Bconfig][here]]) and the way I use it
  is I get only the one I need on the computer I need. This means I
  don't always want the =ruby-config= or the =go-config= on my
  computers. And this means that I don't need these part in my emacs
  configuration as well ; it even might need some dependencies that I
  wouldn't have without the =*-config= repository.

  So, each repository will come (or not =:-P=) with a part of emacs
  configuration, that will be load by the following code. They will
  put their code into =$HOME/.emacs.d/provided/=.


  #+BEGIN_SRC emacs-lisp
    ;; The folder is by default $HOME/.emacs.d/provided
    (setq user-emacs-provided-directory (concat user-emacs-directory "provided/"))
    ;; Regexp to find org files in the folder
    (setq provided-configuration-file-regexp "\\`[^.].*\\.org\\'")
    ;; Define the function
    (defun load-provided-configuration (dir)
      "Load org file from =use-emacs-provided-directory= as configuration with org-babel"
      (unless (file-directory-p dir) (error "Not a directory '%s'" dir))
      (dolist (file (directory-files dir nil provided-configuration-file-regexp nil) nil)
        (unless (member file '("." ".."))
          (let ((file (concat dir file)))
            (unless (file-directory-p file)
              (message "loading file %s" file)
              (org-babel-load-file file)
              )
            ))
        )
      )
    ;; Load it
    (load-provided-configuration user-emacs-provided-directory)
  #+END_SRC

* Automatically invoke tangle on save

  This is the magic line(s) to make the tangle on save automatic.

  #+BEGIN_SRC emacs-lisp :tangle no
# Local Variables:
# eval: (when (fboundp #'tangle-if-config) (add-hook 'after-save-hook #'tangle-if-config))
# End:
  #+END_SRC

  # Local Variables:
  # eval: (when (fboundp #'tangle-if-config) (add-hook 'after-save-hook #'tangle-if-config))
  # End:
