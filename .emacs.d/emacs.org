#+TITLE: Vincent Demeester's emacs configuration
#+AUTHOR: Vincent Demeester
#+EMAIL: vincent [at] demeester [dot] fr

#+begin_src
                                                              ___ __
    .-----.--------.---.-.----.-----.______.----.-----.-----.'  _|__|.-----.
    |  -__|        |  _  |  __|__ --|______|  __|  _  |     |   _|  ||  _  |
    |_____|__|__|__|___._|____|_____|      |____|_____|__|__|__| |__||___  |
                                                                     |_____|
#+end_src

This is my first attempt to create a readable, maintainable and self
documented emacs configuration. I'm hopeful that using Org-Babel and a
literate programming style will help.

There is a lot of inspiration for this file, I'm just gonna list the
one I took the most of it :

- [[https://github.com/joodie/emacs-literal-config/blob/master/emacs.org][Joodie emacs-literal-config]]
- [[https://github.com/dakrone/dakrone-dotfiles/blob/master/.emacs.d/settings.org][Dakrone emacs configuration]]
- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]]
- [[https://github.com/steckerhalter/steckemacs/blob/master/steckemacs.org]["Steckemacs" steckerhalter literal emacs config]]
- [[https://github.com/larstvei/dot-emacs][Lartsvei dot-emacs]]
- [[https://github.com/grettke/home/blob/master/.emacs.el][Grettke emacs configuration]]
- [[https://github.com/jkitchin/jmax][Johns customizations to maximize emacs (jmax)]]
- [[https://github.com/jwiegley/dot-emacs][jwiegley dot-emacs]]

This file is an /always/ work-in-progress, and is currently under
*heavy* modifications. The latest version of this file is always
available at my [[https://github.com/vdemeester/emacs-config][emacs-config]] github repository, the [[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/emacs.org][emacs.org]] file.

It looks kinda like that (click to open the real one) :

[[./.emacs.d/images/emacs-config.png][./.emacs.d/images/emacs-config-small.png]]

* How to use my configuration ðŸš€

  You can obtain the source by cloning this repository somewhere, but the repository
  is made to work with [[https://github.com/RichiH/vcsh][vcsh]].

  #+BEGIN_SRC sh
 vcsh clone git://github.com/vdemeester/emacs-config emacs-config
  #+END_SRC

  If you don't want to use =vcsh= but still want to have my =.emacs.d= folder
  in your =$HOME=, you could link it like that :

  #+BEGIN_SRC sh
 $ cd $HOME
 $ mkdir -p src
 $ git clone git://github.com/vdemeester/emacs-config src/vde-emacs-config
 $ ln -s src/vde-emacs-config/.emacs.d .
  #+END_SRC

** The =init.el=

   If you just want to get the =emacs.org= file, you will have to define and setup
   some stuff for this file to work with org-babel. You could take a look to my
   [[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/init.el][init.el]] file but let's show the main stuff.

   First you will need to setup packages repository and define a =require-package=
   function, let's see what's in there (defined in =lisp/setup-package.el=).


   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'package)

     ;; add org to package repos
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

     ;; add melpa and melpa-stable to package repos
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
     (add-to-list 'package-archives '("mela-stable" . "http://stable.melpa.org/packages/"))

     ;; If gpg cannot be found, signature checking will fail, so we
     ;; conditionally enable it according whether gpg is available.
     ;; We re-run this check once $PATH has been configured
     (defun sanityinc/package-maybe-enable-signatures ()
       (setq package-check-signature (when (executable-find "gpg") 'allow-unsigned)))

     (sanityinc/package-maybe-enable-signatures)

     ;; Fire up package.el
     (package-initialize)

     ;; Load package contents if not present
     (when (not package-archive-contents)
       (package-refresh-contents))

     ;; Load use-package
     (require 'use-package)

     (provide 'setup-package)
   #+END_SRC

   Let's now see how I load the =emacs.org= file. In the following lines of code,
   I'm also ensuring that a recent version of [[http://orgmode.org/][org-mode]] is present on the system ;
   if not, I'm unload the current one, installing a recent one and load it.

   #+BEGIN_SRC emacs-lisp :tangle no
     ;; Support for Emacs 24 and higher only
     (let ((minver 24))
       (unless (>= emacs-major-version minver)
         (error "Your Emacs is too old -- this config requires v%s or higher" minver)))

     ;; Keep track of loading time
     (defconst emacs-start-time (current-time))

     ;; Add custom lisp files to the load-path
     (add-to-list 'load-path "~/.emacs.d/lisp")
     ;; Add a specific version of use-package
     (add-to-list 'load-path "~/.emacs.d/lisp/use-package")

     (require 'vde-functions)
     ;; initialize all ELPA packages
     (require 'setup-package)

     (let ((elapsed (float-time (time-subtract (current-time)
                                                emacs-start-time))))
       (message "Loaded packages in %.3fs" elapsed))

     ;; Make sure we have a decent and recent org-mode version
     (require 'org)
     (when (string-match "^[1234567]" (org-version))
       (progn
         (warn "Org-mode is out of date. We expect org 8 or higher, but instead we have %s" (org-version))
         (warn "Force the installation from org elpa.")
         (package-install 'org)
         (unload-org-mode)
         (require 'org)
         ))

     ;; keep customize settings in their own file
     (setq custom-file
           (expand-file-name "custom.el"
                             user-emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))

     ;; load the literate configuration
     (require 'ob-tangle)

     (org-babel-load-file "~/.emacs.d/emacs.org")

     (let ((elapsed (float-time (time-subtract (current-time)
                                                emacs-start-time))))
       (message "Loaded settings...done in %.3fs" elapsed))
   #+END_SRC

* Personal information ðŸ‘¨

  Let's define default value that could be owerwritten by the host
  and user file ðŸ£. The variables =user-full-name= and
  =user-mail-address= are defined in =~/.emacs.d/user.el= (which is
  private).

  #+BEGIN_SRC emacs-lisp
    (setq
     ;; General
     ;; TODO use xdg to get these
     desktop-folder (substitute-env-in-file-name "$HOME/desktop")
     videos-folder (expand-file-name "videos" desktop-folder)
     downloads-folder (expand-file-name "downloads" desktop-folder)
     music-folder (expand-file-name "music" desktop-folder)
     pictures-folder (expand-file-name "pictures" desktop-folder)
     ;; Orgmode related
     org-root-directory (substitute-env-in-file-name "$HOME/desktop/org")
     org-todos-directory-name "todos"
     org-notes-directory-name "notes"
     org-sites-directory-name "sites"
     org-archive-directory-name "archive"
     org-archive-file-pattern "/%s_archive::"
     org-inbox-file "inbox.org"
     org-main-file "personal.org"
     org-journal-file "journal.org"
     org-stackoverflow-file "stack.org"
     org-zenika-file "zenika.org"
     org-web-article-file "ent.org"
     org-publish-folder (substitute-env-in-file-name "$HOME/var/public_html")
     sites-folder (substitute-env-in-file-name "$HOME/src/sites/")
     ;; Github related
     github-general-folder (substitute-env-in-file-name "$HOME/src/github")
     github-username "vdemeester")
  #+END_SRC

  Loads user settings if the file is available. I put all my personal modifications or sensitive information into this file.

  #+BEGIN_SRC emacs-lisp
 (when (file-readable-p "~/.emacs.d/user.el")
   (load "~/.emacs.d/user.el"))
  #+END_SRC

  Same will goes with host-specific files and os-specific files.

  #+BEGIN_SRC emacs-lisp
 (setq FULLHOSTNAME (format "%s" system-name))
 (setq HOSTNAME (substring (system-name) 0 (string-match "\\." (system-name))))

 (setq HOSTNAME-FILE
       (expand-file-name
        (format "hosts/%s.el" HOSTNAME)
        "~/.emacs.d"))

 (when (file-readable-p HOSTNAME-FILE)
   (load HOSTNAME-FILE))
  #+END_SRC

  And build the /final/ variables with the possibly overwritten ones.


  #+BEGIN_SRC emacs-lisp
    (setq
     ;; Orgmode related
     org-todos-directory (expand-file-name org-todos-directory-name org-root-directory)
     org-notes-directory (expand-file-name org-notes-directory-name org-root-directory)
     org-sites-directory (expand-file-name org-sites-directory-name org-root-directory)
     org-archive-directory (expand-file-name org-archive-directory-name org-root-directory)
     ;; Github related
     github-personal-folder (expand-file-name github-username github-general-folder))
  #+END_SRC


* General configuration ðŸ¸
** Appearance

   Unclutter the screen by removing menubar, toolbar and stuff, and by disabling
   the splash-screen.

   #+begin_src emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (blink-cursor-mode -1)
     (setq inhibit-splash-screen t)
   #+end_src

   We want to see somewhere the column and line number, and also highlight the
   current line to see it easily.

   #+begin_src emacs-lisp
     (line-number-mode 1)
     (column-number-mode 1)
     (global-hl-line-mode 1)
   #+end_src

   Depending on the files opened and the syntax highlighting enabled, ~font-lock-mode~
   can be slow, we try to limit that, to keep Emacs reactive.

   #+begin_src emacs-lisp
     (setq font-lock-maximum-decoration 2)
   #+end_src

*** Fringe decorations

    [[http://www.emacswiki.org/emacs/TheFringe][The fringe]] is the vertical region at the right and left of the
    buffer. Emacs lets you customize it of course.

    Here I set up git diffs and buffer position in the fringe.

    #+BEGIN_SRC emacs-lisp
      (setq-default indicate-buffer-boundaries 'left)
      (setq-default indicate-empty-lines +1)
    #+END_SRC

*** Fonts

    I tend to install Ubuntu font family on all my computers, I like
    it :). But I don't want emacs to fail loading because they aren't
    there yet, so let's define =Ubuntu Mono= as fonts, only if they
    are available.

    #+begin_src emacs-lisp
      ;; Use the following to load it only if present
      ;;(when (member "Ubuntu Mono" (font-family-list))
      ;;  )
      (set-default-font "Ubuntu Mono-12")
      (set-frame-font "Ubuntu Mono-12")
      (set-face-attribute 'default nil :family "Ubuntu Mono" :height 110)
    #+end_src

    This will set Symbola as fallback-font for Emojis when it is
    available for the created frame. Because emojis and unicode are
    cool : ðŸ™† ðŸ˜† ðŸ˜ â™¨ â›… ðŸš².

    #+BEGIN_SRC emacs-lisp
      (set-fontset-font t 'unicode "Symbola" nil 'prepend)
    #+END_SRC

*** Themes

    First let's install the theme(s) and load the new theme

    #+begin_src emacs-lisp
      (use-package spacemacs-theme
        :ensure t
        :init
        (setq spacemacs-theme-org-height t)
        (setq spacemacs-theme-org-highlight t)
        (load-theme 'spacemacs-dark))
    #+end_src

*** Powerline

    We are going to use [[https://github.com/milkypostman/powerline][powerline]] because it is way more sexy than the default modeline design.

    #+begin_src emacs-lisp
      (use-package powerline
                   :ensure t
                   :init
                   (powerline-default-theme))
    #+end_src

** Behaviour

   First thing first, let's define a shortcuts for editing this configuration.


   #+BEGIN_SRC emacs-lisp
     (defun my/edit-emacs-configuration ()
       (interactive)
       (find-file "~/.emacs.d/emacs.org"))

     (global-set-key "\C-ce" 'my/edit-emacs-configuration)
   #+END_SRC


   Although I don't really care, let's add a new line at the end of files.
   Some people at work will thank me for that ;-D.

   #+begin_src emacs-lisp
     (setq require-final-newline t)
   #+end_src

   Answering yes and no to each question from Emacs can be tedious, a single y or n will suffice.

   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   Let Emacs display the unfinished keystroke quickly (by default it's
   1 second).

   #+BEGIN_SRC emacs-lisp
     (setq echo-keystrokes 0.1)
   #+END_SRC

*** Setting the PATH

    I'm playing a lot with the =$PATH= variable in my shell, and I
    sometimes pested that Emacs didn't have the same one. But thanks
    to [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] it's all ok now =:P=.


    #+BEGIN_SRC emacs-lisp
      (use-package exec-path-from-shell
        :ensure t
        :config
        (exec-path-from-shell-initialize)
        (exec-path-from-shell-copy-env "HISTFILE"))
    #+END_SRC


*** Encoding

    Make sur that we use ~utf-8~ by default.

    #+begin_src emacs-lisp
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-language-environment "UTF-8")
      (prefer-coding-system 'utf-8)
    #+end_src

*** Mouse
    Move the mouse away to not bother.

    #+begin_src emacs-lisp
      (mouse-avoidance-mode 'jump)
    #+end_src

*** Backup files

    Files suffixed with =~= in the current directory are ugly. We are still going to use
    backup files, as it can saves some time in case of trouble, but we'll move them
    somewhere else : ~/tmp/emacs-1001~ (for a user with the uid = 1001).

    Note the we store them in /tmp so in case of a reboot, we loose them.

    #+begin_src emacs-lisp
      (defconst emacs-tmp-dir (format "%s/%s%s/" temporary-file-directory "emacs" (user-uid)))
      (setq backup-directory-alist
            `((".*" . ,emacs-tmp-dir))
            auto-save-file-name-transforms
            `((".*" ,emacs-tmp-dir t))
            auto-save-list-file-prefix emacs-tmp-dir)
    #+end_src

    Now that all the temporary files are out of the way, we can keep more of them.

    #+begin_src emacs-lisp
      (setq delete-old-versions t
            kept-new-versions 6
            kept-old-versions 2
            version-control t)
    #+end_src
*** Saving on focus out

    IntelliJ does that and I find it cool, so let's do that in Emacs
    too. In a word, this settings will save buffers when switching
    from Emacs to another window.

    #+BEGIN_SRC emacs-lisp
      ;; http://timothypratley.blogspot.fr/2015/07/seven-specialty-emacs-settings-with-big.html
      (defun save-all ()
        (interactive)
        (save-some-buffers t))
      (add-hook 'focus-out-hook 'save-all)
    #+END_SRC

*** Buffers

    Setup uniquify so that non-unique buffer names get the parent path included to make them unique.

    #+begin_src emacs-lisp
      (use-package uniquify)
      (setq uniquify-buffer-name-style 'forward)
    #+end_src

    Most of the time, when I want to kill the current buffer so let's
    remap the =C-x k= the a function that do that (and no ask) ; it
    will save few keystroke per days =\o/=.


    #+BEGIN_SRC emacs-lisp
      (defun kill-default-buffer ()
        "Kill the currently active buffer"
        (interactive)
        (let (kill-buffer-query-functions) (kill-buffer)))

      (global-set-key (kbd "C-x k") 'kill-default-buffer)
    #+END_SRC

*** Comment/Uncomment region

    There is a cool function in emacs wich is =commend-dwim= (bounded
    to =M-;=). This adds a comment at the right place (at the end of
    the line, up the method, etc..

    Something I'm really use to, with IntelliJ or Eclipse, is being
    able to quickly comment a line or a region with simple
    keystroke. If nothing is selected, it comments the current line,
    if there is a selection, it comments the line selected (even if
    the selection doesn't start at the beginning of line. Let's bind
    it to =C-M-/= (=Ctrl+Alt+/=).


    #+BEGIN_SRC emacs-lisp
      (defun my/toggle-comments ()
          "A modified way to toggle comments, 'Ã -la' ide (intelliJ, Eclipse).
      If no region is selected, comment/uncomment the line. If a region is selected, comment/uncomment this region *but* starting from the begining of the first line of the region to the end of the last line of the region"
        (interactive)
        (save-excursion
          (if (region-active-p)
              (progn
                (setq start (save-excursion
                              (goto-char (region-beginning))
                              (beginning-of-line)
                              (point))
                      end (save-excursion
                            (goto-char (region-end))
                            (end-of-line)
                            (point)))
                (comment-or-uncomment-region start end))
            (progn
              (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
            )))
      (global-set-key (kbd "C-M-/") 'my/toggle-comments)
    #+END_SRC


*** Kill advice

    Let's define few advice with =kill-ring-save= and =kill-region=.

    #+BEGIN_SRC emacs-lisp
      (defadvice kill-region (before slick-cut activate compile)
        "When called interactively with no active region, kill a single line instead."
        (interactive
         (if mark-active (list (region-beginning) (region-end))
           (list (line-beginning-position)
                 (line-beginning-position 2)))))

      (defadvice kill-ring-save (before slick-copy activate compile)
        "When called interactively with no active region, copy a single line instead."
        (interactive
         (if mark-active (list (region-beginning) (region-end))
           (message "Copied line")
           (list (line-beginning-position)
                 (line-beginning-position 2)))))
    #+END_SRC

*** Formatting

     Use space instead on tabs for indentation by default (again some people at work
     will thank me for that).

     #+begin_src emacs-lisp
       (setq-default indent-tabs-mode nil)
       (defcustom indent-sensitive-modes
         '(coffee-mode python-mode haml-mode yaml-mode)
         "Modes for which auto-indenting is suppressed."
         :type 'list)
     #+end_src

     Let's define a few /cleaning/ functions :

- untabify the buffer

#+begin_src emacs-lisp
  (defun my/untabify-buffer ()
    "Untabify the currently visited buffer."
    (interactive)
    (untabify (point-min) (point-max)))

  (defun my/untabify-region-or-buffer ()
    "Untabify a region if selected, otherwise the whole buffer."
    (interactive)
    (unless (member major-mode indent-sensitive-modes)
      (save-excursion
        (if (region-active-p)
            (progn
              (untabify (region-beginning) (region-end))
              (message "Untabify selected region."))
          (progn
            (my/untabify-buffer)
            (message "Untabify buffer.")))
        )))
#+end_src

- ident the buffer, using the mode indentation stuff

#+begin_src emacs-lisp
  (defun my/indent-buffer ()
    "Indent the currently visited buffer."
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun my/indent-region-or-buffer ()
    "Indent a region if selected, otherwise the whole buffer."
    (interactive)
    (unless (member major-mode indent-sensitive-modes)
      (save-excursion
        (if (region-active-p)
            (progn
              (indent-region (region-beginning) (region-end))
              (message "Indented selected region."))
          (progn
            (my/indent-buffer)
            (message "Indented buffer.")))
        (whitespace-cleanup))))
#+end_src

- cleanup the buffer

#+begin_src emacs-lisp
  (defun my/cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (my/indent-buffer)
    (my/untabify-buffer)
    (delete-trailing-whitespace))
#+end_src

- cleanup the region

#+begin_src emacs-lisp
(defun my/cleanup-region (beg end)
  "Remove tmux artifacts from region."
  (interactive "r")
  (dolist (re '("\\\\â”‚\Â·*\n" "\W*â”‚\Â·*"))
    (replace-regexp re "" nil beg end)))
#+end_src

And bind =cleanup-buffer= and =cleanup-region=.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x M-t") 'my/cleanup-region)
  (global-set-key (kbd "C-c n") 'my/cleanup-buffer)
  (global-set-key (kbd "C-C i") 'my/indent-region-or-buffer)
#+end_src

For writing text, I prefer Emacs to do line wrapping for me. Also, superfluous
white-space should be shown. There is two choices here :
=auto-fill-mode= and =visual-line-mode= ; the difference is the one is
actually inserting linke breaks, when the other is just a visual
thing. Most of the time I want =auto-fill-mode= in my text files (or
=org-mode= files), so let's add this as default and handle special
cases.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook
            (lambda()
              (turn-on-auto-fill)
              (setq show-trailing-whitespace 't))
            )
#+END_SRC

Let's also rewrite some built-in to better /default/. Let's start with
[[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][smarter navigation to the beginning of a line]].


#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'smarter-move-beginning-of-line)
#+END_SRC


*** pretty-mode

    Pretty mode turn some stuff prettier, for example in Haskell =/== becomes =â‰ =, or
    =->= becomes =â†’=.

    #+BEGIN_SRC emacs-lisp
      (use-package pretty-mode
                   :ensure t
                   :init
                   (add-hook 'prog-mode-hook
                             'turn-on-pretty-mode))
    #+END_SRC

*** raindow-identifiers

    I read an intersting article about [[https://medium.com/p/3a6db2743a1e/][how to make syntax highlighting more useful]]
    and I really like the concept. And guess what, there's a mode for that.

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-identifiers
        :ensure t
        :init (add-hook 'prog-mode-hook
                        'rainbow-identifiers-mode))
    #+END_SRC
*** Hydra

     #+BEGIN_QUOTE
     Once you summon the Hydra through the prefixed binding (the body + any one head), all heads can be called in succession with only a short extension.

     The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head, arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his original purpose, calling his proper command. This makes the Hydra very seamless, it's like a minor mode that disables itself auto-magically.
     #+END_QUOTE

    Hydra is quite impressive, a [[https://www.youtube.com/watch?v%3D_qZliI1BKzI][video]] is gonna be more than a long
    explanation.


    #+BEGIN_SRC emacs-lisp
      (use-package hydra
        :ensure t
        :config
        (hydra-add-font-lock)
        ;; Zooming
        (defhydra hydra-zoom (global-map "<f2>")
          "zoom"
          ("g" text-scale-increase "in")
          ("l" text-scale-decrease "out"))
        ;; Toggling modes
        (global-set-key
         (kbd "C-c C-v")
         (defhydra hydra-toggle-simple (:color blue)
           "toggle"
           ("a" abbrev-mode "abbrev")
           ("d" toggle-debug-on-error "debug")
           ("f" auto-fill-mode "fill")
           ("t" toggle-truncate-lines "truncate")
           ("w" whitespace-mode "whitespace")
           ("q" nil "cancel")))
        ;; Buffer menu
        (defhydra hydra-buffer-menu (:color pink
                                            :hint nil)
          "
      ^Mark^ ^Unmark^ ^Actions^ ^Search
      ^^^^^^^^----------------------------------------------------------------- (__)
      _m_: mark _u_: unmark _x_: execute _R_: re-isearch (oo)
      _s_: save _U_: unmark up _b_: bury _I_: isearch /------\\/
      _d_: delete ^ ^ _g_: refresh _O_: multi-occur / | ||
      _D_: delete up ^ ^ _T_: files only: % -28`Buffer-menu-files-only^^ * /\\---/\\
      _~_: modified ^ ^ ^ ^ ^^ ~~ ~~
      "
          ("m" Buffer-menu-mark)
          ("u" Buffer-menu-unmark)
          ("U" Buffer-menu-backup-unmark)
          ("d" Buffer-menu-delete)
          ("D" Buffer-menu-delete-backwards)
          ("s" Buffer-menu-save)
          ("~" Buffer-menu-not-modified)
          ("x" Buffer-menu-execute)
          ("b" Buffer-menu-bury)
          ("g" revert-buffer)
          ("T" Buffer-menu-toggle-files-only)
          ("O" Buffer-menu-multi-occur :color blue)
          ("I" Buffer-menu-isearch-buffers :color blue)
          ("R" Buffer-menu-isearch-buffers-regexp :color blue)
          ("c" nil "cancel")
          ("v" Buffer-menu-select "select" :color blue)
          ("o" Buffer-menu-other-window "other-window" :color blue)
          ("q" quit-window "quit" :color blue))
        (define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body))
    #+END_SRC


*** Async & bacground

   =async.el= is a module for doing asynchronous processing in
   Emacs. Let's load it as it's gonna be useful. Let's also load
   =dired-async= for the copy & co to be run asynchroniously (very
   useful with TRAMP).

   #+BEGIN_SRC emacs-lisp
     (use-package async
       :ensure t)
     (use-package dired-async
       :init
       (dired-async-mode 1))
   #+END_SRC

   =bpr= from ilya babanov provides a way to do asynchronuous
   processing in Emacs but with style and output.


   #+BEGIN_SRC emacs-lisp
     (use-package bpr
       :ensure t
       :init
       (setq bpr-colorize-output t)
       (setq bpr-close-after-success t))
   #+END_SRC


*** Dired

    Dired is really a cool mode, let's enhance it.

    First load =dired-x= and set a list of default guess when issuing
    =!= (=dired-do-shell-command=) or =&= (=dired-do-async-shell-command=).

    #+BEGIN_SRC emacs-lisp
      (use-package dired-x)
      (setq dired-guess-shell-alist-user
               '(("\\.pdf\\'" "evince" "okular")
                 ("\\.\\(?:djvu\\|eps\\)\\'" "evince")
                 ("\\.\\(?:jpg\\|jpeg\\|png\\|gif\\|xpm\\)\\'" "geeqie")
                 ("\\.\\(?:xcf\\)\\'" "gimp")
                 ("\\.csv\\'" "libreoffice")
                 ("\\.tex\\'" "pdflatex" "latex")
                 ("\\.\\(?:mp4\\|mkv\\|avi\\|flv\\|ogv\\)\\(?:\\.part\\)?\\'"
                  "mpv")
                 ("\\.\\(?:mp3\\|flac\\)\\'" "mpv")
                 ("\\.html?\\'" "firefox")
                 ("\\.cue?\\'" "audacious")))
      (put 'dired-find-alternate-file 'disabled nil)
    #+END_SRC

    Install dired+.

    #+BEGIN_SRC emacs-lisp
      (setq diredp-hide-details-initially-flag nil)
      (use-package dired+
                   :ensure t
                   :init)
    #+END_SRC

    Then, use nohup to not attach a process to emacs.

    #+BEGIN_SRC emacs-lisp
      (use-package dired-aux)

      (defvar dired-filelist-cmd
        '(("vlc" "-L")))

      (defun dired-start-process (cmd &optional file-list)
        (interactive
         (let ((files (dired-get-marked-files
                       t current-prefix-arg)))
           (list
            (dired-read-shell-command "& on %s: "
                                      current-prefix-arg files)
            files)))
        (let (list-switch)
          (start-process
           cmd nil shell-file-name
           shell-command-switch
           (format
            "nohup 1>/dev/null 2>/dev/null %s \"%s\""
            (if (and (> (length file-list) 1)
                   (setq list-switch
                         (cadr (assoc cmd dired-filelist-cmd))))
                (format "%s %s" cmd list-switch)
              cmd)
            (mapconcat #'expand-file-name file-list "\" \"")))))

      (define-key dired-mode-map "c" 'dired-start-process)
    #+END_SRC

    Let's also add a command to display the size of marked files.

    #+BEGIN_SRC emacs-lisp
      (defun dired-get-size ()
        (interactive)
        (let ((files (dired-get-marked-files)))
          (with-temp-buffer
            (apply 'call-process "/usr/bin/du" nil t nil "-schL" files) ;; -L to dereference (git-annex folder)
            (message
             "Size of all marked files: %s"
             (progn
               (re-search-backward "\\(^[ 0-9.,]+[A-Za-z]+\\).*total$")
               (match-string 1))))))
      (define-key dired-mode-map (kbd "z") 'dired-get-size)
    #+END_SRC

    Add a binding for =find-name-dired=. It will transform a =find=
    /search/ into a dired buffer, which is.. well.. pretty cool =:D=.

    #+BEGIN_SRC emacs-lisp
      (define-key dired-mode-map "F" 'find-name-dired)
    #+END_SRC

    Also add a binding to switch to =wdired= which is the awsomeness
    of awesome, because it let's you edit the dired buffer as a text
    file (changing name, etc.) and will apply it when leaving (=C-c
    C-c=)

    #+BEGIN_SRC emacs-lisp
      (define-key dired-mode-map "e" 'wdired-change-to-wdired-mode)
    #+END_SRC


    Open or re-use the =ansi-term= from the current directory in dired.

    #+BEGIN_SRC emacs-lisp
      (define-key dired-mode-map (kbd "`") 'dired-open-term)
      ;; FIXME it seems not to work propertly..
      (defun dired-open-term ()
        "Open an `ansi-term' that corresponds to current directory."
        (interactive)
        (let ((current-dir (dired-current-directory)))
          (term-send-string
           (terminal)
           (if (file-remote-p current-dir)
               (let ((v (tramp-dissect-file-name current-dir t)))
                 (format "ssh %s@%s\n"
                         (aref v 1) (aref v 2)))
             (format "cd '%s'\n" current-dir)))))
    #+END_SRC

    Customize a bit the dired buffer

    #+BEGIN_SRC emacs-lisp
      (setq dired-listing-switches "-laGh1v --group-directories-first")
    #+END_SRC

    Let's also use =peep-dired= wich allows to quickly preview files
    from a dired buffer (images, â€¦)

    #+BEGIN_SRC emacs-lisp
      (use-package peep-dired
        :ensure t
        :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
        :bind (:map dired-mode-map
                    ("P" . peep-dired))
        )
    #+END_SRC

    Another really cool package is dired-narrow, that allows to
    dynamically filter a dired folder.


    #+BEGIN_SRC emacs-lisp
      (use-package dired-narrow
        :ensure t
        :defer t
        :bind (:map dired-mode-map
                    ("/" . dired-narrow)))
    #+END_SRC



*** Images

    I tend to use emacs to look at images too â€” because it does work,
    and I don't have to open or switch to another viewer (Yeah, I'm
    lazy >_<). The only thing I don't like is that image are in 100%
    and there is no easy way to zoom-in/zoom-out.

    #+BEGIN_SRC emacs-lisp
      (use-package image+
        :ensure t
        :config
        (progn
          (defhydra imagex-sticky-binding (global-map "M-s-l")
            "Manipulating Image"
            ("+" imagex-sticky-zoom-in "zoom in")
            ("-" imagex-sticky-zoom-out "zoom out")
            ("M" imagex-sticky-maximize "maximize")
            ("O" imagex-sticky-restore-original "restore original")
            ("S" imagex-sticky-save-image "save file")
            ("r" imagex-sticky-rotate-right "rotate right")
            ("l" imagex-sticky-rotate-left "rotate left"))))

      (defun my-dired-image-hook ()
        (image-diredx-async-mode 1)
        (image-diredx-adjust-mode 1))

      (use-package image-dired+
        :ensure t
        :config
        (progn
          (add-hook 'dired-mode-hook 'my-dired-image-hook))
        )
    #+END_SRC

*** Search

    Make isearch-forward put the cursor at the start of the search, not the end, so that isearch can be used for navigation. See also http://www.emacswiki.org/emacs/IsearchOtherEnd.


    #+BEGIN_SRC emacs-lisp
 (defun my-isearch-goto-match-beginning ()
   (when (and isearch-forward (not isearch-mode-end-hook-quit)) (goto-char isearch-other-end)))
 (add-hook 'isearch-mode-end-hook 'my-isearch-goto-match-beginning)
    #+END_SRC


*** selection

    One feature of IntelliJ that really rocks is the =C-w= shortcuts
    that select "intelligently". =exand-region= is doing this for
    emacs, see [[http://emacsrocks.com/e09.html][Emacs Rocks Episode 09]]. Let's bind this to =C-== in
    Emacs.

    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :ensure t
        :bind ("C-=" . er/expand-region))
    #+END_SRC

*** Hungry delete

    Hungry-delete is plain and simple, it makes backspace and C-d
    erase all consecutive white space in a given direction (instead of
    just one).

    #+BEGIN_SRC emacs-lisp
      (use-package hungry-delete
        :ensure t
        :config
        (global-hungry-delete-mode))
    #+END_SRC


*** Notifications
    Emacs now has notifications (freedesktop.org specifications)
    built-in. Let's load it for potential needs.

    #+BEGIN_SRC emacs-lisp
      (use-package notifications)
    #+END_SRC

    You can use it like this =\o/=.

    #+BEGIN_SRC emacs-lisp :tangle no
      (notifications-notify
          :title "You've got mail!"
          :body "There's 34 mails unread"
          :app-icon "~/.emacs.d/icons/mail.png"
          :urgency 'low)
    #+END_SRC


*** Zoom(ing)

    Being able to zoom in and out can be cool, especially when
    presenting something with emacs ; so that everybody can see
    what's written.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-+") 'text-scale-increase)
      (global-set-key (kbd "C--") 'text-scale-decrease)
    #+END_SRC

*** Key maps & binding

    [[http://endlessparentheses.com/][Endless Parentheses]] is a great sourse of tips & trick on
    GNU/Emacs. Following [[http://endlessparentheses.com/the-toggle-map-and-wizardry.html][this]] and [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][this]] articles, Let's define some
    keymaps for some quick toggling and launching.

    First, let's define a ~toogle-map~, that will allow to toggle some
    stuff like line numbers, minor modes and stuffs.

    #+BEGIN_SRC emacs-lisp
      (define-prefix-command 'vde/toggle-map)
      ;; The manual recommends C-c for user keys, but C-x t is
      ;; always free, whereas C-c t is used by some modes.
      (define-key ctl-x-map "t" 'vde/toggle-map)
      (define-key vde/toggle-map "d" #'toggle-debug-on-error)
      (define-key vde/toggle-map "f" #'auto-fill-mode)
      (define-key vde/toggle-map "v" #'visual-line-mode)
      (define-key vde/toggle-map "l" #'toggle-truncate-lines)
      (define-key vde/toggle-map "q" #'toggle-debug-on-quit)
      (define-key vde/toggle-map "r" #'dired-toggle-read-only)
      (define-key vde/toggle-map "w" #'whitespace-mode)
      (define-key vde/toggle-map "u" #'subword-mode)
      (define-key vde/toggle-map "p" #'superword-mode)
    #+END_SRC

    And now let's define a ~launcher-map~ to launch major modes and
    useful commands.

    #+BEGIN_SRC emacs-lisp
      (define-prefix-command 'vde/launcher-map)
      (define-key ctl-x-map "l" 'vde/launcher-map)
      (global-set-key (kbd "s-l") 'vde/launcher-map)
      (define-key vde/launcher-map "c" #'calc)
      (define-key vde/launcher-map "d" #'ediff-buffers)
      (define-key vde/launcher-map "f" #'find-dired)
      (define-key vde/launcher-map "g" #'lgrep)
      (define-key vde/launcher-map "G" #'rgrep)
      (define-key vde/launcher-map "h" #'man)    ; Help
      (define-key vde/launcher-map "s" #'shell)
      (define-key vde/launcher-map "r" #'multi-term)
      (define-key vde/launcher-map "t" #'proced) ; top
    #+END_SRC

*** Scrolling

    Taking from [[http://irreal.org/blog/?p%3D3963][here]], ensure that =M-v= always undoes =C-v=, so you can go back exactly.

    #+BEGIN_SRC emacs-lisp
      (setq scroll-preserve-screen-position 'always)
    #+END_SRC

*** Window moving & resizing

    Use ace-window to switch easily windows.

    #+BEGIN_SRC emacs-lisp
      (defun joe-scroll-other-window()
        (interactive)
        (scroll-other-window 1))
      (defun joe-scroll-other-window-down ()
        (interactive)
        (scroll-other-window-down 1))
      ;; From https://github.com/abo-abo/ace-window/wiki but adapted to bepo
      (use-package ace-window
        :ensure t
        :config
        (set-face-attribute 'aw-leading-char-face nil :foreground "deep sky blue" :weight 'bold :height 3.0)
        (set-face-attribute 'aw-mode-line-face nil :inherit 'mode-line-buffer-id :foreground "lawn green")
        (setq aw-keys   '(?a ?u ?i ?e ?t ?s ?r)
              aw-dispatch-always t
              aw-dispatch-alist
              '((?y aw-delete-window     "Ace - Delete Window")
                (?x aw-swap-window       "Ace - Swap Window")
                (?\' aw-flip-window)
                (?\. aw-split-window-vert "Ace - Split Vert Window")
                (?c aw-split-window-horz "Ace - Split Horz Window")
                (?n delete-other-windows "Ace - Maximize Window")
                (?\, delete-other-windows)
                (?k balance-windows)
                (?v winner-undo)
                (?o winner-redo)))

        (when (package-installed-p 'hydra)
          (defhydra hydra-window-size (:color red)
            "Windows size"
            ("c" shrink-window-horizontally "shrink horizontal")
            ("t" shrink-window "shrink vertical")
            ("s" enlarge-window "enlarge vertical")
            ("r" enlarge-window-horizontally "enlarge horizontal"))
          (defhydra hydra-window-frame (:color red)
            "Frame"
            ("e" make-frame "new frame")
            ("y" delete-frame "delete frame"))
          (defhydra hydra-window-scroll (:color red)
            "Scroll other window"
            ("'" joe-scroll-other-window "scroll")
            ("j" joe-scroll-other-window-down "scroll down"))
          (add-to-list 'aw-dispatch-alist '(?w hydra-window-size/body) t)
          (add-to-list 'aw-dispatch-alist '(?l hydra-window-scroll/body) t)
          (add-to-list 'aw-dispatch-alist '(?g hydra-window-frame/body) t))
        (ace-window-display-mode t)
        (winner-mode 1))
    #+END_SRC

    Ace windows uses [[https://github.com/abo-abo/avy][avy]] so use =avy-goto-line= in place of the
    default =goto-line=, as it's better.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "M-g g") 'avy-goto-line)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      ;; install fullframe for list-packages
      (use-package fullframe
        :init
        (progn
          (fullframe list-packages quit-window))
        :ensure t)
    #+END_SRC


*** Popwin

    #+BEGIN_QUOTE
    popwin is a popup window manager for Emacs which makes you free
    from the hell of annoying buffers such like *Help*, *Completions*,
    *compilation*, and etc.
    #+END_QUOTE

    That says it all, it's kind of a must.

    #+BEGIN_SRC emacs-lisp
      (use-package popwin
        :ensure t
        :config
        (progn
          (add-to-list 'popwin:special-display-config `("*Swoop*" :height 0.5 :position bottom))
          (add-to-list 'popwin:special-display-config `("*Warnings*" :height 0.5 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Procces List*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*Messages*" :height 0.5 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Backtrace*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*Compile-Log*" :height 0.5 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Remember*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*All*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*Go Test*" :height 0.3))
          (add-to-list 'popwin:special-display-config `(flycheck-error-list-mode :height 0.5 :regexp t :position bottom))
          (popwin-mode 1)
          (global-set-key (kbd "C-z") popwin:keymap)))
    #+END_SRC


*** Highlight indentation


    #+BEGIN_SRC emacs-lisp
      (use-package highlight-indentation
        :ensure t
        :commands (highlight-indentation-mode highlight-indentation-current-column-mode)
        :init
        (progn
          ;; Add a key to toggle-map
          (define-key vde/toggle-map "C" #'highlight-indentation-mode)
          (define-key vde/toggle-map "c" #'highlight-indentation-current-column-mode))
        :config
        (progn
          (set-face-background 'highlight-indentation-face "#e3e3d3")
          (set-face-background 'highlight-indentation-current-column-face "#c3b3b3")))
    #+END_SRC


*** Key-chord

    I'm going to experiment wiht =key-chord= as I don't really use
    evil (except from undo-tree but can get this without
    =evil=). =key-chord= lets you define keyboard shortcuts that use
    ordinary keys.


    #+BEGIN_SRC emacs-lisp
      ;; Move this elsewhere, it's not related to key-chord
      (defun my/switch-to-previous-buffer ()
        "Switch to previously open buffer.
      Repeated invocations toggle between the two most recently open buffers."
        (interactive)
        (switch-to-buffer (other-buffer (current-buffer) 1)))

      (defun my/org-check-agenda ()
        "Peek at agenda."
        (interactive)
        (cond
         ((derived-mode-p 'org-agenda-mode)
          (if (window-parent) (delete-window) (bury-buffer)))
         ((get-buffer "*Org Agenda*")
          (switch-to-buffer-other-window "*Org Agenda*"))
         (t (org-agenda nil "a"))))

      (use-package key-chord
        :ensure t
        :config
        (progn
          (setq key-chord-one-key-delay 0.16)
          (key-chord-mode 1)
          ;; k can be bound too
          (key-chord-define-global "uu"     'undo)
          (key-chord-define-global "jw"     'ace-window)
          (key-chord-define-global "jj" 'avy-goto-word-1)
          (key-chord-define-global "jl" 'avy-goto-line)
          (key-chord-define-global "jk" 'avy-goto-char)
          (key-chord-define-global "j."
                                   (defhydra join-lines ()
                                     ("<up>" join-line)
                                     ("<down>" (join-line 1))
                                     ("t" join-line)
                                     ("n" (join-line 1)))))
        ;; buffer actions
        (key-chord-define-global "vg"     'eval-region)
        (key-chord-define-global "vb"     'eval-buffer)
        ;; commands
        (key-chord-define-global "FF"     'find-file)
        (key-chord-define-global "xx"     'er/expand-region)
        (key-chord-define-global "JJ"     'my/switch-to-previous-buffer))
    #+END_SRC


*** Undo-tree

    The only thing I used and really like with evil is =undo-tree= so
    let's keep and use it.

    #+BEGIN_SRC emacs-lisp
      ;;; Load undo-tree before evil for the :bind
      (use-package undo-tree
        :ensure t
        :bind (("C-*" . undo-tree-undo))
        :init
        (progn
          (defalias 'redo 'undo-tree-redo)
          (defalias 'undo 'undo-tree-undo)
          (global-undo-tree-mode)
          )
        :config
        (progn
          (setq undo-tree-auto-save-history t)
          (let ((undo-dir (expand-file-name "undo" user-emacs-directory)))
            (setq undo-tree-history-directory-alist (list (cons "." undo-dir))))))
    #+END_SRC

*** Guide-key

    =guide-key.el= displays the available key bindings automatically and dynamically.

    #+BEGIN_SRC emacs-lisp
      (use-package guide-key
        :ensure t
        :config
        (progn
          (setq guide-key/guide-key-sequence t)
          (setq guide-key/text-scale-amount 1)
          (setq guide-key/popup-window-position 'bottom)
          (guide-key-mode 1)
          (defun guide-key/my-hook-function-for-org-mode ()
            ;; (guide-key/add-local-guide-key-sequence "C-c")
            (guide-key/add-local-highlight-command-regexp "org-"))
          (add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)))
    #+END_SRC

** Server mode

   Start a server in not already running. I usually start emacs as a
   daemon when at the start of the computer, but you never know =;-)=.

   I have an error about /unsafe directory/ for =/tmp/emacs100=, that's
   why the advice is there, to ignore the error (from [[http://stackoverflow.com/a/17069276/89249][stackoverflow]]).

   #+BEGIN_SRC emacs-lisp
 (defadvice server-ensure-safe-dir (around
                                    my-around-server-ensure-safe-dir
                                    activate)
   "Ignores any errors raised from server-ensure-safe-dir"
   (ignore-errors ad-do-it))
 (unless (string= (user-login-name) "root")
   (require 'server)
   (when (or (not server-process)
            (not (eq (process-status server-process)
                   'listen)))
     (unless (server-running-p server-name)
       (server-start))))
   #+END_SRC
* Org ðŸ˜Ž

  #+BEGIN_QUOTE
  Org-mode is a powerful system for organizing your complex life with simple plain-text files. It seamlessly integrates all your notes, mindmaps, TODO lists, calendar, day planner, and project schedules into a single system that can be easily searched (e.g. by grep), encrypted (e.g. by GnuPG), backed up and synced (e.g. by Dropbox), imported/exported, and accessed on the go (e.g. on an iPhone or Android smartphone). It can even be used for authoring web pages and documents.
  #+END_QUOTE

  Depending on how this section grows, org-mode might need its own litterate
  org configuration file.

** Standard configuration

     First let's define the default directory for the =org= files, the one to be added
     to the agenda and the archives.

     #+begin_src emacs-lisp
       (require 'find-lisp)
       (setq org-directory org-root-directory)
       (setq org-agenda-files (find-lisp-find-files org-todos-directory "\.org$"))
       ;; (setq org-enforce-todo-dependencies t)
       (setq org-enforce-todo-checkbox-dependencies t)

       ;;open agenda in current window
       (setq org-agenda-window-setup (quote current-window))
       ;;warn me of any deadlines in next 7 days
       (setq org-deadline-warning-days 7)
       ;;show me tasks scheduled or due in next fortnight
       (setq org-agenda-span (quote fortnight))
       ;;don't show tasks as scheduled if they are already shown as a deadline
       (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
       ;;don't give awarning colour to tasks with impending deadlines
       ;;if they are scheduled to be done
       (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))
       ;;don't show tasks that are scheduled or have deadlines in the
       ;;normal todo list
       (setq org-agenda-todo-ignore-deadlines (quote all))
       (setq org-agenda-todo-ignore-scheduled (quote all))
       ;;sort tasks in order of when they are due and then by priority
       (setq org-agenda-sorting-strategy
         (quote
          ((agenda deadline-up priority-down)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
     #+end_src

     We'll also set which files should be opened using org-mode :
     =*.org=, =*.org_archive=, =*.txt=.

     #+begin_src emacs-lisp
       (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
     #+end_src

     Let's /beautify/ org-mode a little bit too, changing some
     defaults


     #+BEGIN_SRC emacs-lisp
       ;;; Change the ellipsis (default is ...)
       (setq org-ellipsis " â†´")
       ;; Change the default bullets
       (font-lock-add-keywords 'org-mode
                               '(("^ +\\([-*]\\) "
                                  (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))
       ;;; Use org-bullets
       (use-package org-bullets
         :config
         (setq org-bullets-face-name (quote org-bullet-face))
         (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
     #+END_SRC


     Let's also define the default /todo-keywords/ and the workflow
     between them.

- =TODO= : task not started yet, part of the backlog :)
- =PROGRESS= : task that are currently in progress, should be a minimum
- =BLOCKED= : task that I start working on but cannot anymore (for
  some reason), thus they are blocked
- =REVIEW= : task that should be done, but I need or wait for a
  review (by someone else or by me)
- =DONE= : task that are completed.
- =ARCHIVED= : same as done but keep it here (and not moving into archive)

  #+begin_src emacs-lisp
    (defface org-progress ; font-lock-warning-face
      (org-compatible-face nil
        '((((class color) (min-colors 16) (background light)) (:foreground "#A197BF" :bold t :background "#E8E6EF" :box (:line-width 1 :color "#A197BF")))
          (((class color) (min-colors 8)  (background light)) (:foreground "blue"  :bold t))
          (t (:inverse-video t :bold t))))
      "Face for PROGRESS keywords."
      :group 'org-faces)
    (defface org-paused ; font-lock-warning-face
      (org-compatible-face nil
        '((((class color) (min-colors 16) (background light)) (:foreground "#D6CCF4" :bold t :background "#ECE9F5" :box (:line-width 1 :color "#D6CCF4")))
          (((class color) (min-colors 8)  (background light)) (:foreground "cyan"  :bold t))
          (t (:inverse-video t :bold t))))
      "Face for PAUSED keywords."
      :group 'org-faces)
    (defface org-cancelled ; font-lock-warning-face
      (org-compatible-face nil
        '((((class color) (min-colors 16) (background light)) (:foreground "#3D3D3D" :bold t :background "#7A7A7A" :box (:line-width 1 :color "#3D3D3D")))
          (((class color) (min-colors 8)  (background light)) (:foreground "black"  :bold t))
          (t (:inverse-video t :bold t))))
      "Face for PROGRESS keywords."
      :group 'org-faces)
    (defface org-review ; font-lock-warning-face
      (org-compatible-face nil
        '((((class color) (min-colors 16) (background light)) (:foreground "#FC9B17" :bold t :background "#FEF2C2" :box (:line-width 1 :color "#FC9B17")))
          (((class color) (min-colors 8)  (background light)) (:foreground "yellow"  :bold t))
          (t (:inverse-video t :bold t))))
      "Face for PROGRESS keywords."
      :group 'org-faces)
    (defface org-blocked ; font-lock-warning-face
      (org-compatible-face nil
        '((((class color) (min-colors 16) (background light)) (:foreground "#FF8A80" :bold t :background "#ffdad6" :box (:line-width 1 :color "#FF8A80")))
          (((class color) (min-colors 8)  (background light)) (:foreground "red"  :bold t))
          (t (:inverse-video t :bold t))))
      "Face for PROGRESS keywords."
      :group 'org-faces)

    (setq org-todo-keywords
          (quote ((sequence "TODO(t!)" "PROGRESS(p!)" "PAUSED" "BLOCKED" "REVIEW" "|" "DONE(d!)" "ARCHIVED")
                  (sequence "REPORT(r!)" "BUG" "KNOWNCAUSE" "|" "FIXED(f!)")
                  (sequence "|" "CANCELLED(c@)"))))


    (setq org-todo-keyword-faces
          (quote (("TODO" . org-todo)
                  ("PROGRESS" . org-progress)
                  ("PAUSED" . org-paused)
                  ("BLOCKED" . org-blocked)
                  ("REVIEW" . org-review)
                  ("DONE" . org-done)
                  ("ARCHIVED" . org-done)
                  ("CANCELLED" . org-cancelled)
                  ("REPORT" . org-todo)
                  ("BUG" . org-blocked)
                  ("KNOWNCAUSE" . org-review)
                  ("FIXED" . org-done))))

    (setq org-todo-state-tags-triggers
          (quote (("CANCELLED" ("CANCELLED" . t)))))
  #+end_src


  I have a folder with notes, where I don't want =auto-fill-mode=
  enabled, but =visual-line-mode=, let's do that.

#+BEGIN_SRC emacs-lisp
  (defun turn-on-auto-visual-line (expression)
    (if buffer-file-name
        (cond ((string-match expression buffer-file-name)
               (progn
                 (auto-fill-mode -1)
                 (visual-line-mode 1))
               ))))
#+END_SRC

  Undefine some binding (=C-c [=, =C-c ]= since this breaks org-agenda files that
  have been defined in this file (a directory).

  #+begin_src emacs-lisp
    (add-hook 'org-mode-hook
              '(lambda ()
                 (org-defkey org-mode-map "\C-c[" 'undefined)
                 (org-defkey org-mode-map "\C-c]" 'undefined)
                 (org-defkey org-mode-map "\C-c;" 'undefined)
                 (turn-on-auto-visual-line (concat org-notes-directory "/*")))
              'append)
  #+end_src

  All org-mode buffers will be automatically saved each hours.

  #+BEGIN_SRC emacs-lisp
       (run-at-time "00:59" 3600 'org-save-all-org-buffers)
  #+END_SRC

  And add some miscellaneous stuff.

  #+BEGIN_SRC emacs-lisp
    (setq
     org-completion-use-ido t         ;; use IDO for completion
     org-cycle-separator-lines 0      ;; Don't show blank lines
     org-catch-invisible-edits 'error ;; don't edit invisible text
     org-refile-targets '((org-agenda-files . (:maxlevel . 6)))
     )
  #+END_SRC

  Let's also define a =org= related keymap map.

  #+BEGIN_SRC emacs-lisp
    (define-prefix-command 'vde/org-map)
    (global-set-key (kbd "C-c o") 'vde/org-map)
    (define-key vde/org-map "p" (lambda () (interactive) (find-file (expand-file-name org-main-file org-todos-directory))))
    (define-key vde/org-map "n" (lambda () (interactive) (find-file org-notes-directory)))
  #+END_SRC

  If a parent has all it's children =DONE=, make it =DONE= too.

  #+BEGIN_SRC emacs-lisp
    (defun org-summary-todo (n-done n-not-done)
      "Switch entry to DONE when all subentries are done, to PROGRESS otherwise."
      (let (org-log-done org-log-states)   ; turn off logging
        (org-todo (if (= n-not-done 0) "DONE" "PROGRESS"))))

    (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
  #+END_SRC

** Speed commands

   Org-mode speed keys (or spee commands) are really cool, here is a
   quotation from the manual

   #+BEGIN_QUOTE
   Single keys can be made to execute commands when the cursor is at the beginning of a headline, i.e., before the first star.
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
     (setq org-use-speed-commands t)
   #+END_SRC

   However the default =n= (next) and =p= (previous) speed keys
   aren't optimal for my use. When I go to the next one using speed
   commands I want the others closed. Let's redefine it.

   #+BEGIN_SRC emacs-lisp
     (defun my/org-show-next-heading-tidily ()
       "Show next entry, keeping other entries closed."
       (if (save-excursion (end-of-line) (outline-invisible-p))
           (progn (org-show-entry) (show-children))
         (outline-next-heading)
         (unless (and (bolp) (org-on-heading-p))
           (org-up-heading-safe)
           (hide-subtree)
           (error "Boundary reached"))
         (org-overview)
         (org-reveal t)
         (org-show-entry)
         (show-children)))

     (defun my/org-show-previous-heading-tidily ()
       "Show previous entry, keeping other entries closed."
       (let ((pos (point)))
         (outline-previous-heading)
         (unless (and (< (point) pos) (bolp) (org-on-heading-p))
           (goto-char pos)
           (hide-subtree)
           (error "Boundary reached"))
         (org-overview)
         (org-reveal t)
         (org-show-entry)
         (show-children)))
   #+END_SRC

   And let's bind it.

   #+BEGIN_SRC emacs-lisp
     (setq org-speed-commands-user '(("n" . my/org-show-next-heading-tidily)
                                     ("p" . my/org-show-previous-heading-tidily)
                                     (":" . org-set-tags-command)
                                     ("c" . org-toggle-checkbox)
                                     ("d" . org-cut-special)
                                     ("P" . org-set-property)
                                     ("C" . org-clock-display)
                                     ("z" . (lambda () (interactive)
                                              (org-tree-to-indirect-buffer)
                                              (other-window 1)
                                              (delete-other-windows)))))
   #+END_SRC

** Captures

   First thing first, bind a key sequence to org-capture.

   #+BEGIN_SRC emacs-lisp
     (define-key vde/org-map "r" 'org-capture)
   #+END_SRC

   Setup captures templates..

   #+BEGIN_SRC emacs-lisp
     (setq org-capture-templates
           '(;; other entries
             ("t" "Inbox list item" entry
              (file+headline (expand-file-name org-main-file org-todos-directory) "Inbox")
              "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n")
             ("z" "Zenika Inbox list item" entry
              (file+headline (expand-file-name org-zenika-file org-todos-directory) "Inbox")
              "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n")
             ("j" "Journal entry" plain
              (file+datetree+prompt (exand-file-name org-journal-file org-root-directory))
              "%K - %a\n%i\n%?\n")
             ;; other entries
             ))
   #+END_SRC

** Links

   #+BEGIN_QUOTE
   One little-know feature of org-mode is that you can define new
   types of links with the aptly named org-add-link-type. The
   applications of this virtue are many.
   #+END_QUOTE

   Let's define one for =grep= and =pt=.

   #+BEGIN_SRC emacs-lisp
     (org-add-link-type
      "grep" 'my/follow-grep-link
      )
     (defun my/follow-grep-link (regexp)
       "Run `rgrep' with REGEXP and FOLDER as argument,
     like this : [[grep:REGEXP:FOLDER]]."
       (setq expressions (split-string regexp ":"))
       (setq exp (nth 0 expressions))
       (grep-compute-defaults)
       (if (= (length expressions) 1)
           (progn
             (rgrep exp "*" (expand-file-name "./")))
         (progn
           (setq folder (nth 1 expressions))
           (rgrep exp "*" (expand-file-name folder))))
       )

     (use-package pt
       :load-path "~/.emacs.d/lisp/pt/")

     ;; pt-regexp (regexp directory &optional args)
     (org-add-link-type
      "pt" 'my/follow-pt-link)
     (defun my/follow-pt-link (regexp)
       "Run `pt-regexp` with REXEP and FOLDER as argument,
     like this : [[pt:REGEXP:FOLDER]]"
       (setq expressions (split-string regexp ":"))
       (setq exp (nth 0 expressions))
       (if (= (length expressions) 1)
           (progn
             (pt-regexp exp (expand-file-name "./")))
         (progn
           (setq folder (nth 1 expressions))
           (pt-regexp exp (file-name-as-directory (expand-file-name folder)))))
       )
   #+END_SRC

   Let's define some for youtube and other media websites.

   #+BEGIN_SRC emacs-lisp
     (defvar yt-iframe-format
       ;; You may want to change your width and height.
       (concat "<iframe width=\"440\""
               " height=\"335\""
               " src=\"https://www.youtube.com/embed/%s\""
               " frameborder=\"0\""
               " allowfullscreen>%s</iframe>"))

     (org-add-link-type
      "youtube"
      (lambda (handle)
        (browse-url
         (concat "https://www.youtube.com/embed/"
                 handle)))
      (lambda (path desc backend)
        (cl-case backend
          (html (format yt-iframe-format
                        path (or desc "")))
          (latex (format "\href{%s}{%s}"
                         path (or desc "video"))))))
   #+END_SRC

   Let's define some for github.com sites.


   #+BEGIN_SRC emacs-lisp
     (org-add-link-type
      "gh" 'my/follow-gh-link)
     (defun my/follow-gh-link (issue)
       "Browse github issue/pr specified"
       (setq expressions (split-string issue "#"))
       (setq project (nth 0 expressions))
       (setq issue (nth 1 expressions))
       (browse-url
        (format "https://github.com/%s/issues/%s" project issue)))
   #+END_SRC


   Add some more abbreviation to links

   #+BEGIN_SRC emacs-lisp
     (setq org-link-abbrev-alist
           '(("gmane" . "http://thread.gmane.org/%s")
             ("google" . "https://www.google.com/search?q=%s")
             ("github" . "http://github.com/%s")
             ))
   #+END_SRC


   And some for =org-mode= itself.

   #+BEGIN_SRC emacs-lisp
     ;; from http://endlessparentheses.com/use-org-mode-links-for-absolutely-anything.html
     (org-add-link-type
      "tag" 'endless/follow-tag-link)

     (defun endless/follow-tag-link (tag)
       "Display a list of TODO headlines with tag TAG.
     With prefix argument, also display headlines without a TODO keyword."
       (org-tags-view (null current-prefix-arg) tag))
   #+END_SRC


** Code blocks

    We are using a lot of code block in org-mode, in this file for example ; let's
    /fontify/ the code blocks first.

    #+begin_src emacs-lisp
      (setq org-src-fontify-natively t)
      (org-babel-do-load-languages
       'org-babel-load-languages
       '( (perl . t)
          (ruby . t)
          (sh . t)
          (python . t)
          (emacs-lisp . t)
          ;; (golang . t)
          (haskell . t)
          (ditaa . t)
          ))
    #+end_src

    Add a function to easily add a code block and bind it.

    #+begin_src emacs-lisp
      (defun my/org-insert-src-block (src-code-type)
        "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
        (interactive
         (let ((src-code-types
                '("emacs-lisp" "python" "C" "sh" "java" "js" "clojure" "C++" "css"
                  "calc" "dot" "gnuplot" "ledger" "R" "sass" "screen" "sql" "awk" 
                  "ditaa" "haskell" "latex" "lisp" "matlab" "org" "perl" "ruby"
                  "sqlite" "rust" "scala" "golang" "restclient")))
           (list (ido-completing-read "Source code type: " src-code-types))))
        (progn
          (newline-and-indent)
          (insert (format "#+BEGIN_SRC %s\n" src-code-type))
          (newline-and-indent)
          (insert "#+END_SRC\n")
          (previous-line 2)
          (org-edit-src-code)))

      (defun my/org-insert-html-block ()
        "Insert a `HTML-BLOCK` type in org-mode."
        (interactive
         (progn
           (newline-and-indent)
           (insert "#+BEGIN_HTML\n")
           (newline-and-indent)
           (insert "#+END_HTML\n")
           (previous-line 2))))


      (defun my/org-insert-blockquote-block ()
        "Insert a `BLOCKQUOTE-BLOCK` type in org-mode."
        (interactive
         (progn
           (newline-and-indent)
           (insert "#+BEGIN_BLOCKQUOTE\n")
           (newline-and-indent)
           (insert "#+END_BLOCKQUOTE\n")
           (previous-line 2))))



      (add-hook 'org-mode-hook
                '(lambda ()
                   (local-set-key (kbd "C-c s e") 'org-edit-src-code)
                   (local-set-key (kbd "C-c s i") 'my/org-insert-src-block)
                   (local-set-key (kbd "C-c s h") 'my/org-insert-html-block)
                   (local-set-key (kbd "C-c s b") 'my/org-insert-blockquote-block))
                'append)
    #+end_src

** Mobile

   Define some stuff for the /org-mobile/ synchronization. The
   =org-mobile-directory= is a on a remote ssh, defined in the
   =~/.emacs.d/user.el= file (using =(setq personal-org-mobile-directory "")=).

   #+BEGIN_SRC emacs-lisp
     (require 'org-mobile)
     (setq org-mobile-directory personal-org-mobile-directory
           org-mobile-inbox-for-pull (expand-file-name org-inbox-file org-todos-directory)
           org-mobile-files '(org-todos-directory))
   #+END_SRC

   Let's also configure auto push, asynchronously like in this
   [[https://gist.github.com/mrvdb/3111823][gist]]. One thing that I should add though is to auto-commit too
   (because my todos are on git).

   #+BEGIN_SRC emacs-lisp
     (defun notify-push (result)
       (notifications-notify
        :title "Push complete"
        :body (format "Org-mobile-push: %s" result)
        ))

     ;; Fork the work of pushing to mobile
     (defun fork-org-push-mobile ()
       (interactive)
       (async-start
        ;; What to do in the child process
        `(lambda ()
           (require 'org)
           ,(async-inject-variables "org-\\(mobile-\\|directory\\)")
           (org-mobile-push))
                                             ; What to do when it finishes
        (lambda (result)
          (notify-push result))))

     ;; Define a timer variable
     (defvar org-mobile-push-timer nil
       "Timer that `org-mobile-push-timer' used to reschedule itself, or nil.")

     ;; Push to mobile when the idle timer runs out
     (defun org-mobile-push-with-delay (secs)
       (when org-mobile-push-timer
         (cancel-timer org-mobile-push-timer))
       (setq org-mobile-push-timer
             (run-with-idle-timer
              (* 1 secs) nil 'fork-org-push-mobile)))

     ;; After saving files, start a 30 seconds idle timer after which we
     ;; are going to push
     (add-hook 'after-save-hook
               (lambda ()
                 (when (eq major-mode 'org-mode)
                   (dolist (file (org-mobile-files-alist))
                     (if (string= (expand-file-name (car file)) (buffer-file-name))
                         (org-mobile-push-with-delay 30)))
                   )))

     ;; At least run it once a day, but no need for a delay this time
     (run-at-time "12:05" 86400 '(lambda () (org-mobile-push-with-delay 1)))
   #+END_SRC


** Archives

   We want to be able to archive some /done/ projects. Let's load
   org-archive and configure it.

   #+BEGIN_SRC emacs-lisp
     (require 'org-archive)
     (setq org-archive-location (concat org-archive-directory org-archive-file-pattern))
   #+END_SRC

** Tags

   Tags should be displayed from the 90 column.

   #+BEGIN_SRC emacs-lisp
     (setq org-tags-column -90)
   #+END_SRC

   Define a list of default tags that should apply for all org-mode
   buffers.

   #+BEGIN_SRC emacs-lisp
     ;; Wish I could use taggroup but it doesn't seem to work..
     (setq org-tag-alist '(
                           ("important" . ?i)
                           ("urgent" . ?u)
                           ("ongoing" . ?o)         ;; ongoing "project", use to filter big project that are on the go
                           ("next" . ?n)            ;; next "project"/"task", use to filter next things to do
                           ("@home" . ?h)           ;; needs to be done at home
                           ("@work" . ?w)           ;; needs to be done at work
                           ("@client" . ?c)         ;; needs to be done at a client place (consulting..)
                           ("dev" . ?e)             ;; this is a development task
                           ("infra" . ?a)           ;; this is a sysadmin/infra task
                           ("document" . ?d)        ;; needs to produce a document (article, post, ..)
                           ("download" . ?D)        ;; needs to download something
                           ("media" . ?m)           ;; this is a media (something to watch, listen, record, ..)
                           ("mail" . ?M)            ;; mail-related (to write & send or to read)
                           ("triage" . ?t)          ;; need "triage", tag it to easily find them
                           ("task" . ?a)            ;; a simple task (no project), the name is kinda misleading
                           ;; docker tags
                           ("docker")
                           ("compose")
                           ("libcompose")
                           ("distribution")
                           ("docs")
                           ("rancher")
                           ;; sites tags
                           ("sites")
                           ("vdf")
                           ("znk")
                           ;; configs tags
                           ("configs")
                           ("emacs")
                           ("i3")
                           ("shell")
                           ;; services
                           ("services")
                           ;; zenika
                           ("znk")
                           ("formation")
                           ("event")
                           ("tribu")
                           ("devops")
                           ("craftmanship")
                           ("client")
                           ))
   #+END_SRC

   Note that =important= and =urgent= helps me prioritize my
   /todos/, in a /quadrant fashion way/.

   | Important          | *Kaizen*        | *Panic*             |
   | /tag important/    | improvements    | emergency           |
   |--------------------+-----------------+---------------------|
   | Less Important     | *Organics*      | Social *investment* |
   | /no tag important/ | inspiration     | Social activities   |
   |--------------------+-----------------+---------------------|
   |                    | Less Urgent     | Urgent              |
   |                    | /no tag urgent/ | /tag urgent/        |


** Agenda(s)

   First thing first, bind a key sequence to org-agenda.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c a") 'org-agenda)
   #+END_SRC

   Then set custom agendas.. For the syntax, look in worg : [[http://orgmode.org/worg/org-tutorials/advanced-searching.html][Advanced
   searching]] and [[http://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][Custom Agenda Commands]].

   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-custom-commands
           '(("t" todo "TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("p" todo "PROGRESS"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("r" todo "REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("a" todo "PAUSED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("b" todo "BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("o" "Ongoing projects" tags-todo "ongoing"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-tags-exclude-from-inheritance '("ongoing"))
               (org-agenda-prefix-format "  Mixed: ")))
             ("n" "Next tasks" tags-todo "next"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-tags-exclude-from-inheritance '("next"))
               (org-agenda-prefix-format "  Mixed: ")))
             ("i" "Triage tasks â€” to look" tags-todo "triage"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ;; Timelines
             ("d" "Timeline for today" ((agenda "" ))
              ((org-agenda-ndays 1)
               (org-agenda-show-log t)
               (org-agenda-log-mode-items '(clock closed))
               (org-agenda-clockreport-mode t)
               (org-agenda-entry-types '())))
             ("w" "Weekly review" agenda ""
              ((org-agenda-span 7)
               (org-agenda-log-mode 1)))
             ("W" "Weekly review sans DAILY" agenda ""
              ((org-agenda-span 7)
               (org-agenda-log-mode 1)
               (org-agenda-tag-filter-preset '("-DAILY"))))
             ("2" "Bi-weekly review" agenda "" ((org-agenda-span 14) (org-agenda-log-mode 1)))
             ;; Panic tasks : urgent & important
             ;; Probably the most important to do, but try not have to much of them..
             ("P" . "Panic -emergency-")
             ("Pt" "TODOs" tags-todo "important&urgent/!TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Pb" "BLOCKEDs" tags-todo "important&urgent/!BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Pr" "REVIEWs" tags-todo "important&urgent/!REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ;; Kaizen tasks : important but not urgent
             ("K" . "Kaizen -improvement-")
             ("Kt" "TODOs" tags-todo "important&-urgent/!TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Kb" "BLOCKEDs" tags-todo "important&-urgent/!BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Kr" "REVIEWs" tags-todo "important&-urgent/!REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ;; Social investment : urgent
             ("S" . "Social -investment-")
             ("St" "TODOs" tags-todo "-important&urgent/!TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Sb" "BLOCKEDs" tags-todo "-important&urgent/!BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Sr" "REVIEWs" tags-todo "-important&urgent/!REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ;; Organics
             ("O" . "Organics -inspiration-")
             ("Ot" "TODOs" tags-todo "-important&-urgent/!TODO"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Ob" "BLOCKEDs" tags-todo "-important&-urgent/!BLOCKED"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("Or" "REVIEWs" tags-todo "-important&-urgent/!REVIEW"
              ((org-agenda-sorting-strategy '(priority-down))
               (org-agenda-prefix-format "  Mixed: ")))
             ("N" search ""
              ((org-agenda-files '("~org/notes.org"))
               (org-agenda-text-search-extra-files nil)))))
   #+END_SRC

** Pomodoro

   #+BEGIN_SRC emacs-lisp
     (use-package org-pomodoro
       :ensure t
       :init
       (setq org-pomodoro-play-sounds 1)
       (setq org-pomodoro-audio-player "paplay"))
   #+END_SRC

** Publishing

   Let's configure the publishing part of org-mode. The first
   org-mode files we want to publish are in =~/desktop/org/{project}=,
   and we want to publish them in =~/var/public_html/{project}= for
   now.

   Few org-export and org-html configuration.

   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :ensure t
       :defer t)
     ;;      (setq org-html-head "<link rel=\"stylesheet\" type=\"text/css\" hrefl=\"css/stylesheet.css\" />")
     (setq org-html-include-timestamps nil)
     ;; (setq org-html-htmlize-output-type 'css)
     (setq org-html-head-include-default-style nil)
   #+END_SRC

   And the projects.

   #+BEGIN_SRC emacs-lisp
     (use-package ox-publish)
     ;; (use-package ox-rss)

     ;; Define some variables to write less :D
     (setq sbr-base-directory (expand-file-name "sbr" org-sites-directory)
           sbr-publishing-directory (expand-file-name "sbr" org-publish-folder)
           znk-base-directory (expand-file-name "zenika" org-sites-directory)
           znk-preview-publishing-directory (expand-file-name "zenika" org-publish-folder)
           znk-publishing-directory (expand-file-name "zenika-export" org-publish-folder)
           vdf-base-directory (expand-file-name "vdf" org-sites-directory)
           vdf-site-directory (expand-file-name "blog" sites-folder)
           vdf-publishing-directory (expand-file-name "posts" (expand-file-name "content" vdf-site-directory))
           vdf-static-directory (expand-file-name "static" vdf-site-directory)
           vdf-css-publishing-directory (expand-file-name "css" vdf-static-directory)
           vdf-assets-publishing-directory vdf-static-directory)

     ;; Project
     (setq org-publish-project-alist
           `(("sbr-notes"
              :base-directory ,sbr-base-directory
              :base-extension "org"
              :publishing-directory ,sbr-publishing-directory
              :makeindex t
              :exclude "FIXME"
              :recursive t
              :htmlized-source t
              :publishing-function org-html-publish-to-html
              :headline-levels 4
              :auto-preamble t
              :html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" />"
              :html-preamble "<div id=\"nav\">
     <ul>
     <li><a href=\"/\" class=\"home\">Home</a></li>
     </ul>
     </div>"
              :html-postamble "<div id=\"footer\">
     %a %C %c
     </div>")
             ("sbr-static"
              :base-directory ,sbr-base-directory
              :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg"
              :publishing-directory ,sbr-publishing-directory
              :recursive t
              :publishing-function org-publish-attachment
              )
             ("sbr" :components ("sbr-notes" "sbr-static"))
             ("vdf-notes"
              :base-directory ,vdf-base-directory
              :base-extension "org"
              :publishing-directory ,vdf-publishing-directory
              :exclude "FIXME"
              :section-numbers nil
              :with-toc nil
              :with-drawers t
              :htmlized-source t
              :publishing-function org-html-publish-to-html
              :headline-levels 4
              :body-only t)
             ("vdf-static-css"
              :base-directory ,vdf-base-directory
              :base-extension "css"
              :publishing-directory ,vdf-css-publishing-directory
              :recursive t
              :publishing-function org-publish-attachment
              )
             ("vdf-static-assets"
              :base-directory ,vdf-base-directory
              :base-extension "png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg"
              :publishing-directory ,vdf-assets-publishing-directory
              :recursive t
              :publishing-function org-publish-attachment
              )
             ("vdf" :components ("vdf-notes" "vdf-static-css" "vdf-static-assets"))
             ("znk-notes"
              :base-directory ,znk-base-directory
              :base-extension "org"
              :publishing-directory ,znk-publishing-directory
              :exclude "FIXME"
              :section-numbers nil
              :with-toc nil
              :with-drawers t
              :recursive t
              :htmlized-source t
              :publishing-function org-html-publish-to-html
              :headline-levels 4
              :body-only t)
             ("znk-notes-previews"
              :base-directory ,znk-base-directory
              :base-extension "org"
              :publishing-directory ,znk-preview-publishing-directory
              :makeindex t
              :exclude "FIXME"
              :recursive t
              :htmlized-source t
              :publishing-function org-html-publish-to-html
              :headline-levels 4
              :auto-preamble t
              :html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" />"
              :html-preamble "<div id=\"nav\">
     <ul>
     <li><a href=\"/\" class=\"home\">Home</a></li>
     </ul>
     </div>"
              :html-postamble "<div id=\"footer\">
     %a %C %c
     </div>")
             ("znk-static"
              :base-directory ,znk-base-directory
              :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg"
              :publishing-directory ,znk-publishing-directory
              :recursive t
              :publishing-function org-publish-attachment
              )
             ("znk" :components ("znk-notes" "znk-notes-previews" "znk-static"))
             ))
   #+END_SRC

   Now, I also want to use =org-mode= for some of my talks (if not
   all), and [[https://github.com/coldnew/org-ioslide][=org-ioslide=]] looks pretty good.


   #+BEGIN_SRC emacs-lisp
     (use-package ox-ioslide
       :ensure t)
   #+END_SRC


** Protocol

   Trying out org-protocol based on
   http://oremacs.com/2015/01/07/org-protocol-1/ and
   http://oremacs.com/2015/01/08/org-protocol-2/.


   #+BEGIN_SRC emacs-lisp
     (use-package org-capture)
     (use-package org-protocol)
     (setq org-protocol-default-template-key "l")
     (push '("l" "Link" entry (function org-handle-link)
             "* TODO %(org-wash-link)\nAdded: %U\n%(org-link-hooks)\n%?")
           org-capture-templates)

     (defun org-wash-link ()
       (let ((link (caar org-stored-links))
             (title (cadar org-stored-links)))
         (setq title (replace-regexp-in-string
                      " - Stack Overflow" "" title))
         (org-make-link-string link title)))

     (defvar org-link-hook nil)

     (defun org-link-hooks ()
       (prog1
           (mapconcat #'funcall
                      org-link-hook
                      "\n")
         (setq org-link-hook)))

     (defun org-handle-link ()
       (let ((link (caar org-stored-links))
             file)
         (cond ((string-match "^https://www.youtube.com/" link)
                (org-handle-link-youtube link))
               ((string-match (regexp-quote
                               "http://stackoverflow.com/") link)
                (find-file ((expand-file-name org-stackoverflow-file org-notes-directory)))
                (goto-char (point-min))
                (re-search-forward "^\\*+ +Questions" nil t))
               (t
                (find-file ((expand-file-name org-web-article-file org-notes-directory)))
                (goto-char (point-min))
                (re-search-forward "^\\*+ +Articles" nil t)))))

     (defun org-handle-link-youtube (link)
       (lexical-let*
           ((file-name (org-trim
                        (shell-command-to-string
                         (concat
                          "youtube-dl \""
                          link
                          "\""
                          " -o \"%(title)s.%(ext)s\" --get-filename"))))
            (dir videos-folder)
            (full-name
             (expand-file-name file-name dir)))
         (add-hook 'org-link-hook
                   (lambda ()
                     (concat
                      (org-make-link-string dir dir)
                      "\n"
                      (org-make-link-string full-name file-name))))
         (async-shell-command
          (format "youtube-dl \"%s\" -o \"%s\"" link full-name))
         (find-file (org-expand "ent.org"))
         (goto-char (point-min))
         (re-search-forward "^\\*+ +videos" nil t)))
   #+END_SRC
* Other Modes ðŸ¥
** Discover my major

   #+BEGIN_QUOTE
   Discover key bindings and their meaning for the current Emacs major mode.

   The command is inspired by discover.el and also uses the makey library. I thought, â€œHey! Why not parse the information about the major mode bindings somehow and display that like discover.el doesâ€¦â€
   #+END_QUOTE


   #+BEGIN_SRC emacs-lisp
     (use-package discover-my-major
       :ensure t
       :bind ("C-h C-m" . discover-my-major))
   #+END_SRC
** Helm

    #+BEGIN_QUOTE
    Helm is incremental completion and selection narrowing framework for Emacs. It will help steer you in the right direction when youâ€™re looking for stuff in Emacs (like buffers, files, etc).

    Helm is a fork of anything.el originaly written by Tamas Patrovic and can be considered to be its successor. Helm sets out to clean up the legacy code in anything.el and provide a cleaner, leaner and more modular tool, thatâ€™s not tied in the trap of backward compatibility.
    #+END_QUOTE

    By default the /completion/ on the selected line is done by =C-z=
    (the function is =helm-execute-persistent-action=) and =Tab= is
    used for showing action you can do on it. Let's invert them as
    =Tab= is used for completion in other tools (shells for example).

    Let's define that all helm commands will be prefixed by =C-h=,
    =C-h x= will be =Helm M-x=.

    #+begin_src emacs-lisp
      (use-package helm
        :ensure t
        :config
        (progn
          (use-package helm-config)
          (setq helm-idle-delay 0.1
                helm-input-idle-delay 0.1
                helm-buffer-max-length 40
                helm-M-x-always-save-history t
                helm-move-to-line-cycle-in-source t
                helm-ff-file-name-history-use-recentf t
                ;; Enable fuzzy matching
                helm-M-x-fuzzy-match t
                helm-buffers-fuzzy-matching t
                helm-recentf-fuzzy-match t)
          (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
          ;; Rebind actions
          (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
          (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
          (define-key helm-map (kbd "C-z") 'helm-select-action)
          (helm-autoresize-mode t)
          (helm-mode 1))
        :bind (("C-c h" . helm-command-prefix)
               ("C-x C-f" . helm-find-files)
               ("M-x" . helm-M-x)
               ("C-c b" . helm-mini)
               ("C-x C-b" . helm-buffers-list)
               ("M-y" . helm-show-kill-ring)
               ("C-c M-i" . helm-imenu)
               ("C-x c o" . helm-occur)))
      ;; (add-to-list 'helm-completing-read-handlers-alist '(org-refile)) ; helm-mode does not do org-refile well
      ;; (add-to-list 'helm-completing-read-handlers-alist '(org-agenda-refile)) ; same goes for org-agenda-refile
    #+end_src

    Because it can be hard to remember all keybindings, let's use
    =helm-descbinds=.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-descbinds
        :ensure t
        :defer t
        :bind ("C-h b" . helm-descbinds))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package helm-gtags
        :ensure t)
      ;; (helm-gtags-mode 1)
    #+END_SRC


    #+BEGIN_SRC emacs-lisp
      (use-package helm-grep
        :config
        (progn
          (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
          (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
          (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)))
    #+END_SRC

    I'm trying [[https://github.com/monochromegane/the_platinum_searcher][the platinium searcher]] as it's kinda quick, so I'm
    trying helm-ag with specifiec configuration.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-ag
        :ensure
        :config
        (setq helm-ag-base-command "pt -e --nocolor --nogroup"
              helm-ag-command-option "--all-text"
              helm-ag-insert-at-point 'symbol)
        (define-key helm-ag-mode-map (kbd "<return>")  'helm-ag-mode-jump-other-window)
        (define-key helm-ag-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
        (define-key helm-ag-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward))
    #+END_SRC


*** helmp-make

    #+BEGIN_SRC emacs-lisp
      (use-package helm-make
        :ensure t)
    #+END_SRC


*** helm-swoop

    =helm-swoop= is a great Helm powered buffer search/occur interface:

    #+BEGIN_SRC emacs-lisp
      (use-package helm-swoop
        :ensure t
        :defer t
        :bind (("C-S-s" . helm-swoop)
               ("M-I" . helm-swoop-back-to-last-point))
        :config
        (progn
          (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
          (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)))
    #+END_SRC
*** helm-google

    #+BEGIN_QUOTE
    Emacs Helm Interface for quick Google searches
    #+END_QUOTE

    #+BEGIN_SRC emacs-lisp
      (use-package helm-google
        :ensure t)
    #+END_SRC


*** helm-firefox

    Because helm is soo fun :D.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-firefox
        :ensure t)
    #+END_SRC

** Company-mode

   #+BEGIN_QUOTE
   Company is a text completion framework for Emacs. The name stands
   for "complete anything". It uses pluggable back-ends and front-ends
   to retrieve and display completion candidates.
   #+END_QUOTE


   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :config
       (progn
         (add-hook 'after-init-hook 'global-company-mode)
         (setq company-tooltip-limit 20)                      ; bigger popup window
         (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
         (setq company-echo-delay 0)                          ; remove annoying blinking
         (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
         ))
   #+END_SRC

** deft

   #+BEGIN_QUOTE
   Deft is an Emacs mode for quickly browsing, filtering, and editing
   directories of plain text notes, inspired by Notational Velocity.
   #+END_QUOTE

   Deft is cool to use with org-mode, let's use it for notes.

   #+BEGIN_SRC emacs-lisp
     (use-package deft
       :ensure t
       :config
       (progn
         (setq deft-extension "org"
               deft-text-mode 'org-mode
               deft-directory org-notes-directory
               deft-use-filename-as-title t))
       :bind ("<f9>" . deft))
   #+END_SRC

** Version control integration
*** Git

    #+begin_src emacs-lisp
      (use-package git-commit
        :ensure t)
      (use-package gitignore-mode
        :ensure t)
      (use-package gitconfig-mode
        :ensure t)
      (use-package gitattributes-mode
        :ensure t)
    #+end_src


**** magit

     #+begin_src emacs-lisp
       (use-package magit
         :ensure t
         :commands magit-status
         :bind ("C-c g" . magit-status)
         :config
         (add-to-list 'magit-no-confirm 'stage-all-changes)
         (setq magit-push-always-verify nil)
         (setq magit-last-seen-setup-instructions "2.1.0"))
     #+end_src

**** git fringe decoration

     #+begin_src emacs-lisp
       (use-package git-gutter-fringe
           :ensure t
           :config (global-git-gutter-mode +1))
     #+end_src emacs-lisp

**** git-annex

     [[http://git-annex.branchable.com/][Git-annex]] is a wonderful piece of software that I use a lot in my repositories.

     #+BEGIN_QUOTE
     git-annex allows managing files with git, without checking the file contents into git. While that may seem paradoxical, it is useful when dealing with files larger than git can currently easily handle, whether due to limitations in memory, time, or disk space.
     #+END_QUOTE

     In Emacs, it integrates with magit and dired mode. The annex subcommand for magit is ~@~.

     #+begin_src emacs-lisp
       (use-package git-annex
         :ensure t)
       (use-package magit-annex
         :ensure t)
     #+end_src

**** git-timemachine
     I recently discovered an extremely cool package called git-timemachine that allows you to step though the git history of the file youâ€™re currently editing in Emacs.

     #+BEGIN_SRC emacs-lisp
       (use-package git-timemachine
         :ensure t)
     #+END_SRC

**** git-blame

     #+BEGIN_SRC emacs-lisp
       (use-package git-blame
         :ensure t)
     #+END_SRC

** highlight-symbol

   #+BEGIN_QUOTE
   Automatic and manual symbol highlighting for Emacs
   #+END_QUOTE

   Highlights the word/symbol at point and any other occurrences in
   view. Also allows to jump to the next or previous occurrence.


   #+BEGIN_SRC emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :config
       (progn
         (setq highlight-symbol-on-navigation-p t)
         (add-hook 'prog-mode-hook 'highlight-symbol-mode))
       :bind (("C-<f3>" . highlight-symbol-at-point)
              ("<f3>" . highlight-symbol-next)
              ("S-<f3>" . highlight-symbol-prev)
              ("M-<f3>" . highlight-symbol-query-replace)))
   #+END_SRC

** move-text

   Allows to move the current line or region up/down. The source code is
   on the Wiki: http://www.emacswiki.org/emacs/move-text.el

   #+BEGIN_SRC emacs-lisp
     (use-package move-text
       :ensure t
       :config (move-text-default-bindings))
   #+END_SRC

** Diff

   The =diff-mode= of Emacs is pretty cool, but let's show important
   whitespace when in this mode.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'diff-mode-hook (lambda ()
                                 (setq-local whitespace-style
                                             '(face
                                               tabs
                                               tab-mark
                                               spaces
                                               space-mark
                                               trailing
                                               indentation::space
                                               indentation::tab
                                               newline
                                               newline-mark))
                                 (whitespace-mode 1)))
   #+END_SRC

   Setup ediff so that it does not open a new frame (it is a pain in a
   tiling window manager).

   #+BEGIN_SRC emacs-lisp
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
     (setq ediff-split-window-function 'split-window-horizontally)
     (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
   #+END_SRC


** Eshell

   Starting to use a bit =eshell=, first let's kill the buffer on exit.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'shell-mode-hook 'wcy-shell-mode-hook-func)
     (defun wcy-shell-mode-hook-func  ()
       (set-process-sentinel (get-buffer-process (current-buffer))
                             #'shell-mode-kill-buffer-on-exit)
       )
     (defun shell-mode-kill-buffer-on-exit (process state)
       (message "%s" state)
       (if (or
            (string-match "exited abnormally with code.*" state)
            (string-match "finished" state))
           (kill-buffer (current-buffer))))
   #+END_SRC


** Terminal

   Let's install and use [[http://www.emacswiki.org/emacs/MultiTerm][multi-term]], which is a cool addition to =term.el=.

   #+BEGIN_SRC emacs-lisp
     (use-package multi-term
       :ensure t
       :bind (("M-[" . multi-term-prev)
              ("M-]" . multi-term-next)))
   #+END_SRC

** multiple-cursors

   Multiple cursors for Emacs, this is a pretty /badass/ functionnality.

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind (("C-S-c C-S-c" . mc/edit-lines)
              ("C->" . mc/mark-next-like-this)
              ("C-<" . mc/mark-previous-like-this)
              ("C-c C-<" . mc/mark-all-like-this)))
   #+END_SRC


** Flyspell

   #+BEGIN_QUOTE
   Flyspell enables on-the-fly spell checking in Emacs by the means of
   a minor mode. It is called Flyspell. This facility is hardly
   intrusive. It requires no help. Flyspell highlights incorrect words
   as soon as they are completed or as soon as the TextCursor hits a
   new word.
   #+END_QUOTE


   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :ensure t
       :init
       (progn
         (use-package flyspell-lazy
           :ensure t))
       :config
       (progn
         (define-key vde/toggle-map "i" #'ispell-change-dictionary)
         (define-key vde/launcher-map "i" #'flyspell-buffer)
         (setq ispell-program-name "aspell")
         (setq ispell-local-dictionary "en_US")
         (setq ispell-local-dictionary-alist
               '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8)
                 ("fr_FR" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8)))
         (add-hook 'text-mode-hook 'flyspell-mode)
         (add-hook 'prog-mode-hook 'flyspell-prog-mode)))
   #+END_SRC


** Flycheck

   #+BEGIN_QUOTE
   Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs 24, intended as replacement for the older Flymake extension which is part of GNU Emacs.

   It uses various syntax checking and linting tools to check the contents of buffers, and reports warnings and errors directly in the buffer, or in an optional error list.
   #+END_QUOTE

   Let's install it and configure it for the common part. The language
   specifics will be defined in the corresponding language section.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :config
       (progn
         (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
         (setq flycheck-indication-mode 'right-fringe)
         (add-hook 'after-init-hook #'global-flycheck-mode)))
   #+END_SRC

** Projectile

   #+BEGIN_QUOTE
   Projectile is a project interaction library for Emacs. Its goal is
   to provide a nice set of features operating on a project level
   without introducing external dependencies(when feasible). For
   instance - finding project files has a portable implementation
   written in pure Emacs Lisp without the use of GNU find (but for
   performance sake an indexing mechanism backed by external commands
   exists as well).
   #+END_QUOTE


   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :config
       (progn
         (setq projectile-completion-system 'default)
         (setq projectile-enable-caching t)
         (setq projectile-indexing-method 'alien)
         (projectile-global-mode)))
   #+END_SRC

   And let's use the helm integration too.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile
       :ensure t
       :config
       (progn
         (setq projectile-switch-project-action 'helm-projectile)
         (helm-projectile-on))
       )
   #+END_SRC

*** Perspective

    [[https://github.com/nex3/perspective-el][Perspective]] is a minor mode that provides the ability to manage
    different workspaces. It integrates well with projectile.

    #+BEGIN_SRC emacs-lisp
      (use-package perspective
        :ensure t
        :init
        (progn
          (setq persp-show-modestring nil)
          (add-hook 'persp-switch-hook 'hack-dir-local-variables-non-file-buffer)
          (persp-mode)))
      (use-package persp-projectile
        :ensure t
        :requires perspective
        :init
        (progn
          (define-key projectile-command-map (kbd "p") 'projectile-persp-switch-project)
          (persp-mode)))
    #+END_SRC
** Compilation mode

   Set options and key binding for =compile=.


   #+BEGIN_SRC emacs-lisp
     (use-package compile
       :commands compile
       :bind ("<f5>" . compile)
       :config
       (progn
         (setq compilation-ask-about-save nil
               compilation-always-kill t
               compilation-scroll-output 'first-error)
         ))
   #+END_SRC


*** Compilation mode improvements

    See http://stackoverflow.com/questions/3072648/cucumbers-ansi-colors-messing-up-emacs-compilation-buffer


    #+BEGIN_SRC emacs-lisp
      (require 'ansi-color)
      (defun my/colorize-compilation-buffer ()
        (toggle-read-only)
        (ansi-color-apply-on-region (point-min) (point-max))
        (toggle-read-only))
      (add-hook 'compilation-filter-hook 'my/colorize-compilation-buffer)
    #+END_SRC

    And let's configure the compilation-mode to follow the compilation, not waiting
    at the top..

    #+BEGIN_SRC emacs-lisp
      (setq compilation-scroll-output t)
      ;; I'm not scared of saving everything.
      (setq compilation-ask-about-save nil)
      ;; Stop on the first error.
      (setq compilation-scroll-output 'next-error)
      ;; Don't stop on info or warnings.
      (setq compilation-skip-threshold 2)
    #+END_SRC

** Provided configuration

   I'm managing my configurations using [[https://github.com/RichiH/vcsh][vcsh]] and [[http://myrepos.branchable.com/][myrepos]], like [[https://github.com/vdemeester/vcsh-home#how-it-is-supposed-to-work][that]]. I have a lot
   of different configuration repository ([[https://github.com/search?q%3Duser%253Avdemeester%2Bconfig][here]]) and the way I use it
   is I get only the one I need on the computer I need. This means I
   don't always want the =ruby-config= or the =go-config= on my
   computers. And this means that I don't need these part in my emacs
   configuration as well ; it even might need some dependencies that I
   wouldn't have without the =*-config= repository.

   So, each repository will come (or not =:-P=) with a part of emacs
   configuration, that will be load by the following code. They will
   put their code into =$HOME/.emacs.d/provided/=.


   #+BEGIN_SRC emacs-lisp
     ;; The folder is by default $HOME/.emacs.d/provided
     (setq user-emacs-provided-directory (concat user-emacs-directory "provided/"))
     ;; Regexp to find org files in the folder
     (setq provided-configuration-file-regexp "\\`[^.].*\\.org\\'")
     ;; Define the function
     (defun load-provided-configuration (dir)
       "Load org file from =use-emacs-provided-directory= as configuration with org-babel"
       (unless (file-directory-p dir) (error "Not a directory '%s'" dir))
       (dolist (file (directory-files dir nil provided-configuration-file-regexp nil) nil)
         (unless (member file '("." ".."))
           (let ((file (concat dir file)))
             (unless (file-directory-p file)
               (message "loading file %s" file)
               (org-babel-load-file file)
               )
             ))
         )
       )
     ;; Load it
     (load-provided-configuration user-emacs-provided-directory)
   #+END_SRC
** Lisp(s)
*** General

    Let's install some LISP common useful modes.

    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :ensure t)
      (use-package rainbow-mode
        :ensure t)
      (use-package rainbow-delimiters
        :ensure t)
      (use-package highlight-parentheses
        :ensure t)
    #+END_SRC

    And define a comme lisp hook for all LISP-related prog-modes, mostly about
    parentheses.

    #+BEGIN_SRC emacs-lisp
      (defun my/lisps-mode-hook ()
        (paredit-mode t)
        (rainbow-delimiters-mode t)
        (highlight-parentheses-mode t)
        )
    #+END_SRC

*** Emacs lisp

    Define some useful alias (just because I'm lazy).


    #+BEGIN_SRC emacs-lisp
      (defalias 'eb 'eval-buffer)
      (defalias 'er 'eval-region)
      (defalias 'ed 'eval-defun)
    #+END_SRC


    #+BEGIN_SRC emacs-lisp
      (add-hook 'emacs-lisp-mode-hook
                (lambda ()
                  (my/lisps-mode-hook)
                  (eldoc-mode 1))
                )
    #+END_SRC

*** Clojure

    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :ensure t
        :config
        (progn
          (add-hook 'clojure-mode-hook 'my/lisps-mode-hook)))
    #+END_SRC

**** cider

     #+BEGIN_SRC emacs-lisp
       (use-package cider
         :ensure t)
     #+END_SRC
** SQL

   Emacs is really more than an editor. The SQL mode is quick and cool to
   used (and do not eat my memory like mysql-workbench for
   example).

   By default, Emacs does not automatically truncate long lines in
   SQL(i) mode, let's change that.

#+BEGIN_SRC emacs-lisp
     (add-hook 'sql-interactive-mode-hook
               (lambda ()
                 (toggle-truncate-lines t)))
#+END_SRC

** Linux related modes
*** Archlinux
    I'm using [[http://archlinux.org][Archlinux]] on my personnal computers and I maintain a few packages
    on [[https://aur.archlinux.org][aur]], hopefully there is a mode for that.

    #+BEGIN_SRC emacs-lisp
      (use-package pkgbuild-mode
        :ensure t)
    #+END_SRC

** Markdown, Yaml & Toml

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t)
     (use-package markdown-mode+
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package toml-mode
       :ensure t)
   #+END_SRC

** Docker ðŸ³

   I'm playing a lot with [[http://docker.com][docker]] and most of the time editing
   Dockerfile and stuff inside Emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :ensure t)
   #+END_SRC

   Now let's have more fun, we're going to use [[https://github.com/Silex/docker.el][docker.el]] project. As
   it's early development and I'm interested in, we'll use my fork
   that is checked-out in =$HOME/.emacs.d/lisp/docker= folder (using
   =$HOME/.config/mr/groups.d/emacs-config=).

   #+BEGIN_SRC emacs-lisp
     ;; Install dependencies
     (use-package magit-popup
       :ensure t)
     (use-package docker
       :ensure t
       :config
       (docker-global-mode 1))
   #+END_SRC

*** docker-dev minor mode

    I use heavily emacs when developping on docker with go-config (I
    might make more general minor mode that are golang centric but
    this is my first attempt).

     #+BEGIN_SRC emacs-lisp
       ;; Define some function
       (defun test-integration-cli ()
         "Run test-integration-cli for docker. If the symbol-at-point is a test,
       a func starting with Test, it will only run this one, otherwise it will
       prompt for the expression to run. It will run all if the expression is empty."
         )

       ;; Define the minor mode
       (define-minor-mode docker-dev-mode
         "Provide function to ease the dev on Docker projects :3"
         :lighter "ðŸ³"
         :keymap (let ((map (make-sparse-keymap)))
                   (define-key map (kbd "C-c f") 'insert-foo)
                   map)
         )
    #+END_SRC



** Restclient

   Soâ€¦ I needed to hack a bit around the [[https://docker.com][Docker]] client API and wanted
   to do this in Emacs (why not =:-)=). And well [[https://github.com/pashky/restclient.el][restclient.el]] is
   pretty awesome.

   #+BEGIN_SRC emacs-lisp
     (use-package restclient
       :ensure t)
     (use-package ob-restclient
       :ensure t
       :config
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((restclient . t))))
   #+END_SRC

** Ansible

   [[http://docs.ansible.com/index.html][Ansible]] is a great automation tool I use to manage my servers and
   desktops.

   #+BEGIN_SRC emacs-lisp
     (use-package ansible
       :ensure t
       :config
       (progn
         (add-hook 'yaml-mode-hook '(lambda () (ansible 1)))))
   #+END_SRC

   The following snippet is taken from [[http://www.lunaryorn.com/2014/07/18/ansible-docs-in-emacs.html][lunaryorn article]] about getting
   ansible doc in emacs.

   #+BEGIN_SRC emacs-lisp
     (defconst lunaryorn-ansible-doc-buffer " *Ansible Doc*"
       "The Ansible Doc buffer.")

     (defvar lunaryorn-ansible-modules nil
       "List of all known Ansible modules.")

     (defun lunaryorn-ansible-modules ()
       "Get a list of all known Ansible modules."
       (unless lunaryorn-ansible-modules
         (let ((lines (ignore-errors (process-lines "ansible-doc" "--list")))
               modules)
           (dolist (line lines)
             (push (car (split-string line (rx (one-or-more space)))) modules))
           (setq lunaryorn-ansible-modules (sort modules #'string<))))
       lunaryorn-ansible-modules)

     (defun lunaryorn-ansible-doc (module)
       "Show ansible doc for MODULE."
       (interactive
        (list (ido-completing-read "Ansible Module: "
                                   (lunaryorn-ansible-modules)
                                   nil nil nil nil nil
                                   (thing-at-point 'symbol 'no-properties))))
       (let ((buffer (get-buffer-create lunaryorn-ansible-doc-buffer)))
         (with-current-buffer buffer
           (setq buffer-read-only t)
           (view-mode)
           (let ((inhibit-read-only t))
             (erase-buffer)
             (call-process "ansible-doc" nil t t module))
           (goto-char (point-min)))
         (display-buffer buffer)))
   #+END_SRC

   Let's bind it.

   #+BEGIN_SRC emacs-lisp
 (eval-after-load 'yaml-mode
   '(define-key yaml-mode-map (kbd "C-c h a") 'lunaryorn-ansible-doc))
   #+END_SRC

** Yasnippet

   Use YASnippet for snippets.

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :config
       (progn
         (setq yas-verbosity 1
               yas-snippet-dir (expand-file-name "snippets" user-emacs-directory))
         (define-key yas-minor-mode-map (kbd "<tab>") nil)
         (define-key yas-minor-mode-map (kbd "TAB") nil)
         (define-key yas-minor-mode-map (kbd "<C-tab>") 'yas-expand)
         (yas-global-mode 1)))
     (use-package helm-c-yasnippet
       :ensure t
       :bind ("C-c y" . helm-yas-complete))
   #+END_SRC


** Clean the modeline

   With all the modes (major & minor), the modeline becomes really
   big and unusable ; let's clean it.

   #+BEGIN_SRC emacs-lisp
     ;; FIXME handle this with provided configuration
     (defvar mode-line-cleaner-alist
       `((auto-complete-mode         . " Î±")
         (yas-minor-mode             . " Î³")
         (paredit-mode               . " Î¦")
         (eldoc-mode                 . "")
         (abbrev-mode                . "")
         (undo-tree-mode             . " Ï„")
         (volatile-highlights-mode   . " Ï…")
         (elisp-slime-nav-mode       . " Î´")
         (nrepl-mode                 . " Î·Î¶")
         (nrepl-interaction-mode     . " Î·Î¶")
         (cider-mode                 . " Î·Î¶")
         (cider-interaction          . " Î·Î¶")
         (highlight-parentheses-mode . "")
         (highlight-symbol-mode      . "")
         (projectile-mode            . "")
         (helm-mode                  . "")
         (ace-window-mode            . "")
         (magit-auto-revert-mode     . "")
         (sh-mode                    . "sh")
         (org-mode                   . "ê™®")
         (go-mode                    . "ðŸ¹")
         (oracle-mode                . "â˜¯")
         (docker-mode                . "ðŸ³")
         (compilation-minor-mode     . "ðŸš¨")
         (compilation-mode           . "ðŸš¨")
         (company-mode               . "")
         (guide-key-mode             . "")
         ;; Major modes
         (term-mode                  . "âŒ¨")
         (clojure-mode               . " Æ–")
         (hi-lock-mode               . "")
         (visual-line-mode           . " Ï‰")
         (auto-fill-function         . " Ïˆ")
         (python-mode                . " Py")
         (emacs-lisp-mode            . " EL")
         (markdown-mode              . " md")
         (magit                      . "")
         (haskell-mode               . " Î»")
         (lisp-interaction-mode      . " Î¶")
         (lisp-mode                  . " Î¶")
         (flyspell-mode              . "")
         (flymake-mode               . "")
         (flycheck-mode              . ""))
       "Alist for `clean-mode-line'.

     When you add a new element to the alist, keep in mind that you
     must pass the correct minor/major mode symbol and a string you
     want to use in the modeline *in lieu of* the original.")

     (defun clean-mode-line ()
       (interactive)
       (loop for cleaner in mode-line-cleaner-alist
             do (let* ((mode (car cleaner))
                       (mode-str (cdr cleaner))
                       (old-mode-str (cdr (assq mode minor-mode-alist))))
                  (when old-mode-str
                    (setcar old-mode-str mode-str))
                  ;; major mode
                  (when (eq mode major-mode)
                    (setq mode-name mode-str)))))


     (add-hook 'after-change-major-mode-hook 'clean-mode-line)


     ;;; Greek letters - C-u C-\ greek ;; C-\ to revert to default
     ;;; Ï‚ Îµ Ï Ï„ Ï… Î¸ Î¹ Î¿ Ï€ Î± Ïƒ Î´ Ï† Î³ Î· Î¾ Îº Î» Î¶ Ï‡ Ïˆ Ï‰ Î² Î½ Î¼
   #+END_SRC
** Gist

   Interact with Github gist(s) from Emacs :)

   #+BEGIN_SRC emacs-lisp
     (use-package gist
       :ensure t
       :config
       (setq gist-view-gist t))
   #+END_SRC


** Scratch

   Simple engouh : load a new \*scratch\* buffer with the current
   mode.

   #+BEGIN_SRC emacs-lisp
     (use-package scratch
       :ensure t
       :config
       (progn
         (define-key vde/launcher-map "b" #'scratch)))
   #+END_SRC




